<!DOCTYPE html> <html><head>
		<title>Rendering</title>
		<base href="../../../">
		<meta id="root-path" root-path="../../../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="Documents - Rendering">
		<meta property="og:title" content="Rendering">
		<meta property="og:description" content="Documents - Rendering">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://azoor-desu.gitlab.io/azoor-desu/knowledgebase-&amp;-notes/programming/graphics/rendering.html">
		<meta property="og:image" content="https://azoor-desu.gitlab.io/azoor-desu/lib/media/pasted-image-20240819004713.png">
		<meta property="og:site_name" content="Documents">
		<meta name="author" content="Azoor"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="stylesheet" href="lib/styles/theme.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-dark show-inline-title show-ribbon outliner-plugin-dnd mk-readable-line mk-folder-lines mk-spaces-enabled mk-inline-context-enabled mk-flow-seamless"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="General">General</h1><div class="heading-wrapper"><div class="heading-children"><div><p dir="auto">For GLSL/GLM, use <strong>COLUMN MAJOR</strong> format.</p></div><div><pre><code>0 3 6
1 4 7
2 5 8
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">Different of the usual ROW MAJOR format.</p></div><div><pre><code>0 1 2
3 4 5
6 7 8
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">Terms: <strong>Canonical</strong> means origin at bottom left</p></div><div><p dir="auto">3D Pipeline: <code>Model Coords &gt; World Coords &gt; View Coords(Cam local system) &gt; Lighting stuff &gt; Project onto Camera plane &gt; Clip Coords &gt; Persepctive division &gt; NDC *OPENGL TAKES OVER* &gt; Screen/Device Coords &gt; Framebuffer</code> </p></div><div><p dir="auto">2D Pipeline: <code>Model Coords &gt; World Coords &gt; View Coords(Cam local system) &gt; NDC *OPENGL TAKES OVER* &gt; Screen/Device Coords &gt; Framebuffer</code></p></div><div><p dir="auto">NDC: Origin at center, -1 to 1.<br>
Viewport: Origin Bottom Left, 2x2.</p></div><div><p dir="auto">Screen/Device Coords System:<br>
Origin TOP LEFT, size is dependent. If full device resolution, 1920x1080. If a window, then whatever the window size is e.g. 800x600. Windows OS has this layout.</p></div><div><blockquote dir="auto">
<p>OpenGL does conversion from NDC to Screen/Device Coords automagically.</p>
</blockquote></div></div></div><div class="heading-wrapper"><h1 data-heading="Line Rasterizaction" dir="auto" class="heading" id="Line_Rasterizaction">Line Rasterizaction</h1><div class="heading-children"><div><p dir="auto">Using y=mx+c, we can calculate which pixel is on the line as we iterate through each pixel on X axis. But we don't wanna run the m*x + c every iteration, more expensive. Instead, find the increment of y for every x (aka the m value) and use that to apply iteratively. </p></div><div><p dir="auto"><code>next x = last x + m</code>. </p></div><div><p dir="auto">Pros: Avoids a mult operation<br>
Cons: Will lose accuracy if done for long periods due to float inaccuracy. Does calculations in floats. Not the best.<br>
<span alt="Pasted image 20240819004713.png" src="Pasted image 20240819004713.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819004713.png" src="lib/media/pasted-image-20240819004713.png"></span></p></div><div><p dir="auto">If slope is &gt; 1, iterating across x will miss some pixels cos the behind pixel is being "covered". Instead, iterate via y instead, and use the slope of run/rise instead.<br>
<span alt="Pasted image 20240819004730.png" src="Pasted image 20240819004730.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819004730.png" src="lib/media/pasted-image-20240819004730.png"></span><br>
<span alt="Pasted image 20240819004735.png" src="Pasted image 20240819004735.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819004735.png" src="lib/media/pasted-image-20240819004735.png"></span><br>
Step 1: Iterate thru X values or Y values, depending on the slope and what startpoint/endpoint order is. Prepare a dy/dx or dx/dy value to increment to the not-iterating value. e.g. if iterating x, each x++ is +=dy/dx for y. </p></div><div><p dir="auto">Step 2: Let's say iterate Y value. Take the BOTTOM LEFT of each cell and see what X value it is. </p></div><div><p dir="auto">Step 3: Cell to be colored will be the Y value and X value! Visually, it's going to be the BOTTOM LEFT edges of the cell that is being "marked" by those 2 values. Step 4: iterate all the way, done. Make sure to leave the last cell unset if need line loops or sth.</p></div><div><p dir="auto"><span alt="Pasted image 20240819004819.png" src="Pasted image 20240819004819.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819004819.png" src="lib/media/pasted-image-20240819004819.png"></span></p></div><div><p dir="auto">Full Video Explanation:<br>
Bresenham's Algorithm<br>
<a rel="noopener" class="external-link" href="https://youtu.be/RGB-wlatStc?t=885" target="_blank">https://youtu.be/RGB-wlatStc?t=885</a></p></div><div><p dir="auto">Idea: For each X iteration, a Y value will be provided from the PREVIOUS iteration (unless it's the first iteration, Y value is alr given as the first point). That Y value will be either the same as the last Y value, or Y++. This algorithm figures out if the NEXT Y value should be ++ or not. </p></div><div><p dir="auto">To figure out if ++ or not, we use if( (d1-d2) &gt; 0). If this d1-d2 is -ve, use BOTTOM PIXEL. Else, TOP PIXEL.<br>
<span alt="Pasted image 20240819004904.png" src="Pasted image 20240819004904.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819004904.png" src="lib/media/pasted-image-20240819004904.png"></span><br>
d1 is calculated by the actual Y value of the line - current Y value d2 vice versa. </p></div><div><p dir="auto"><code>d1 - d2</code> is BOTTOM minus TOP. If value is +ve, bottom is fatter, hence line closer to TOP. Else closer to bottom. </p></div><div><p dir="auto">Take note if going the opposite way on the x or y axis will result in a different formula! </p></div><div><p dir="auto">But hol up, we still need to use m! That's a float and das not good.<br>
<span alt="Pasted image 20240819004933.png" src="Pasted image 20240819004933.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819004933.png" src="lib/media/pasted-image-20240819004933.png"></span><br>
we sub m = dy/dx and do algebra on it, then apply dx on both sides. now we got <code>dx(d1 - d2) = 2dy*xk - 2dx*yk + 2dy+2dx*c-dx</code><br>
This is a decision parameter, let's call it Pk. Prata calls it dk.<br>
<span alt="Pasted image 20240819004954.png" src="Pasted image 20240819004954.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819004954.png" src="lib/media/pasted-image-20240819004954.png"></span><br>
In formula <code>P(k) = 2dy*xk - 2dx*yk + 2dy+2dx*c-dx</code>, the last half <code>2dy+2dx*c-dx</code> got removed cos the next few steps are to find <code>P(k + 1) - P(k)</code>, and the constants would have cancelled each other out instantly.</p></div><div><p dir="auto"><code>P(k + 1) - P(k)</code> is useful for doing <em>incremental</em> calculations for the CPU for optimization. However, as a human, using P(k) is good enough.</p></div><div><p dir="auto">If P(k) is +ve, TOP pixel! Else, BOTTOM pixel! <strong>You probably cannot memorise this formula as it differs if you are doing in the negative direction.</strong></p></div><div><p dir="auto">However, when actually drawing lines, who the fuck cares, make your line start bottom left and go top right.</p></div><div><p dir="auto">Oh, and the c in the formula comes from y=mx+c.</p></div><div><p dir="auto">Do this:<br>
Using <code>y= mx + c</code>, sub in <code>dy/dx</code> and then rearrange to get <code>2dx*c = ???</code> At the end of the day you should get the equation for P(k) = xxx that just needs: the current (k) X and Y value, dy and dx.<br>
<span alt="Pasted image 20240819005048.png" src="Pasted image 20240819005048.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819005048.png" src="lib/media/pasted-image-20240819005048.png"></span><br>
and also one smol one for finding initial P<br>
<span alt="Pasted image 20240819005056.png" src="Pasted image 20240819005056.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819005056.png" src="lib/media/pasted-image-20240819005056.png"></span><br>
OK GRAPE TLDR FOR BRESENHAM:<br>
These formulas ONLY WORK for <strong>positive iterations</strong>. If you need to iterate backwards, well just don't lol. You can always choose to iterate forwards. Backwards will require a different formula that is really only useful for prata's exams.<br>
Check if each dy/dx value is +ve or -ve to determine the octant, and use that to decide each pixel should += 1 or -= 1 in X and Y directions.<br>
<strong>MODULUS THE dy AND dx VALUES FIRST BEFORE CONTINUING.</strong> This is making sure you're iterating forwards ON THE X AXIS, as the formula only works this way.</p></div><div><pre><code>Pinitial = 2dy - dx  // P1 to start out with
P+ve = 2dy - 2dx     // If current P value is +ve, add this value to get next P.
P-ve = 2dy           // If current P value is -ve, add this value to get next P.
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">If P is +ve this iteration, next step's y will += 1. If -ve, REMAIN AS SAME VALUE.</p></div><div><p dir="auto">OK grape, this is for slopes 0-1 for both +ve and -ve. How about 1-inf? Just flip the dys with the dxs in the formula, GRAPE. Also, be sure to iterate along the Y axis this time, not X.</p></div><div class="heading-wrapper"><h2 data-heading="Incremental Line Rasterization" dir="auto" class="heading" id="Incremental_Line_Rasterization"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Incremental Line Rasterization</h2><div class="heading-children"><div><p dir="auto">Incremental edge equation: ax+by+c = eval </p></div><div><ol>
<li data-line="0" dir="auto">Calculate eval at desired starting x,y point (bottom left). </li>
<li data-line="1" dir="auto">As you iterate over x++, the new (x+1, y) eval will be eval + a. Delta in x dir is a. 3</li>
<li data-line="2" dir="auto">As you move up to the next row using y++, take the eval value RIGHT BELOW the new point (not the one at the right side after u x++'d) and + b. so (x, y+1) will be eval + b. Delta in y dir is b.</li>
</ol></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="Triangle Rasterization" dir="auto" class="heading" id="Triangle_Rasterization">Triangle Rasterization</h1><div class="heading-children"><div><p dir="auto">When you want to "color" a grid of squares to best represent a triangle on the screen.</p></div><div class="heading-wrapper"><h2 data-heading="Edge Walking" dir="auto" class="heading" id="Edge_Walking"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Edge Walking</h2><div class="heading-children"><div><p dir="auto">An easy method, but inefficient.<br>
<strong>Edge Walking method:</strong> If triangle has no horizontal edge, use the MIDDLE vertex to draw a horizontal line to break a triangle into 2 pieces. Also, take note if this point is to the LEFT or RIGHT. For the 1/2 pieces of triangle, use the 2 corresponding line equations to compute the SPAN. For y = 5, what are the 2 x values for each line? Then iterate through these X values to calculate the fragment positions. </p></div><div><p dir="auto">PROS: Easy to use after implementation<br>
CONS: Too many edge cases. Complicated setup. Middle point to left or right? Do i need to cut the triangle? Cannot be parallelised. Serial computation.<br>
<span alt="Pasted image 20240819013535.png" src="Pasted image 20240819013535.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819013535.png" src="lib/media/pasted-image-20240819013535.png"></span></p></div></div></div><div class="heading-wrapper"><h2 data-heading="Edge Equation" dir="auto" class="heading" id="Edge_Equation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Edge Equation</h2><div class="heading-children"><div><p dir="auto">A more sophisticated method: <strong>Edge Equation Method:</strong><br>
For each fragment, calculate if this current fragment is within the 3 lines. Each line will divide 2D plane into 2 regions, "inside" or "outside". If fragment is "inside" all 3 line equations, then it is inside the triangle.</p></div><div><p dir="auto">So it's just 3 dot product checks per fragment. Neat!<br>
<span alt="Pasted image 20240819013655.png" src="Pasted image 20240819013655.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819013655.png" src="lib/media/pasted-image-20240819013655.png"></span></p></div><div><p dir="auto">For standardization, use the LEFT normal. When dot product'ing a fragment (vector) to the normal, +ve means it's to the left of the line, which is "inside". This conforms with ccw winding of triangles, so DON'T use the right side normal. Given the vector, the left normal is: <code>[-v.y, v.x]</code>. Normalize as needed.<br>
<span alt="Pasted image 20240819013713.png" src="Pasted image 20240819013713.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819013713.png" src="lib/media/pasted-image-20240819013713.png"></span></p></div><div><p dir="auto">So now, the problem will be getting the line equation to do the computation of this inside-outside thing, from the 3 points of the triangle.</p></div><div><p dir="auto">For a given line, create an edge equation that returns a bool to see if fragment is inside or outside. Using point-normal formula explicit format: <code>L : ax + by + c == 0</code>, derived from <code>L: n . (x - p) == 0</code> Need to find <code>a</code>, <code>b</code> and <code>c</code>. <code>a</code> and <code>b</code> are the x and y values of the normal, <code>c</code> is just some fucked up value.<br>
<span alt="Pasted image 20240819014108.png" src="Pasted image 20240819014108.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819014108.png" src="lib/media/pasted-image-20240819014108.png"></span><br>
Hence the function should be: Take in point p and q, and variable point x. If (ax + by + c) &gt;= 0 then TRUE, else FALSE.</p></div><div><p dir="auto">Now here comes another issue: If the point/fragment/pixel lies directly on the the imaginary line, is it in or out? In other words, if (ax + by + c) == 0 then what do?</p></div><div><p dir="auto">Solution: Top left rule. If this line is a "top" line or "left" line of the triangle, then consider it inside. Else, out.</p></div><div><pre><code>Pre-computing Is Top or left edge boolean
if (a != 0) {
  if (a&gt;0) return true; // left edge
  else return false; // right edge
} 
else (a == 0){
  if (b&lt;0) return true; // top
  else return false; // not top
}
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto"><span alt="Pasted image 20240819014201.png" src="Pasted image 20240819014201.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819014201.png" src="lib/media/pasted-image-20240819014201.png"></span></p></div><div><p dir="auto">How to tell if a line/edge is a top/left/right?</p></div><div><p dir="auto">Identifying Top Edges and Left edges:<br>
Is Top when: If line is HORIZONTAL (X value of normal is == 0) and both y-values ABOVE the point/fragment/pixel.<br>
<span alt="Pasted image 20240819015000.png" src="Pasted image 20240819015000.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819015000.png" src="lib/media/pasted-image-20240819015000.png"></span><br>
Is Left when: X value of normal is &gt; 0. V is always pointing DOWNWARDS. Based on CCW winding, the next point that allows for CCW is always to the RIGHT.<br>
In <code>ax + by + c == 0</code>, <code>a == 0</code> and y values above last point is HORIZONTAL EDGE. <code>a &gt; 0</code> is LEFT EDGE<br>
<span alt="Pasted image 20240819015014.png" src="Pasted image 20240819015014.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819015014.png" src="lib/media/pasted-image-20240819015014.png"></span><br>
Note: If the top edge isn't perfectly HORIZONTAL, then it's either a left or right edge. There can also be 2 left edges. </p></div><div><p dir="auto">Also, when calculating if a PIXEL is in or out of the triangle, use its MID POINT. So the int coords of a fragment (x,y) will need to become (x + 0.5, y + 0.5) </p></div><div><p dir="auto">Calculate ax + by + c for every line. If value is +ve for all, fragment is INSIDE triangle.</p></div><div><p dir="auto">Therefore, TLDR:</p></div><div><pre><code>Pre-computing Is Top or left edge boolean for each edge:
if (a != 0) {
  if (a&gt;0) return true; // left edge
  else return false; // right edge
} 
else (a == 0){
  if (b&lt;0) return true; // top
  else return false; // not top
}
</code><button class="copy-code-button">Copy</button></pre></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="Texture Mapping Basics" dir="auto" class="heading" id="Texture_Mapping_Basics">Texture Mapping Basics</h1><div class="heading-children"><div class="heading-wrapper"><h2 data-heading="Texture Space VS Texel space" dir="auto" class="heading" id="Texture_Space_VS_Texel_space"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Texture Space VS Texel space</h2><div class="heading-children"><div><p dir="auto">TLDR: Texture space is NORMALIZED while Texel is in RAW PIXELS, INT ONLY. Note: Texel space can be used to represent a view port, OR the raw image itself (since the size of a raw image is pixels x pixels)<br>
<span alt="Pasted image 20240819005324.png" src="Pasted image 20240819005324.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819005324.png" src="lib/media/pasted-image-20240819005324.png"></span><br>
<span alt="Pasted image 20240819005329.png" src="Pasted image 20240819005329.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819005329.png" src="lib/media/pasted-image-20240819005329.png"></span><br>
With mapping, different methods of applying texture becomes available, such as:<br>
Tiling, stretching, mirroring etc.</p></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="Texture Blending (Decal)" dir="auto" class="heading" id="Texture_Blending_(Decal)">Texture Blending (Decal)</h1><div class="heading-children"><div><p dir="auto"><a rel="noopener" class="external-link" href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendFunc.xhtml" target="_blank">https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendFunc.xhtml</a><br>
Consider an object with existing color. You apply a texture onto the object, and you want it to kind of "fade" in and out of the underlying texture, like a disappearing blood stain fading away.</p></div><div><p dir="auto">One method is to interpolate between these 2 textures using a singular value to determine if one texture or another is fully shown, or in-between.</p></div><div><p dir="auto">The formula is:<br>
<code>Final Color = InterpAmount * TexColor + (1 - InterpAmount) * ObjColor</code></p></div><div><p dir="auto">InterpAmount is the interpolation amount, and should be between 0 to 1.<br>
When value is 1, only TexColor is shown.<br>
When value is 0, only ObjColor is shown.<br>
Anything in between, there will be a color blend!</p></div></div></div><div class="heading-wrapper"><h1 data-heading="Back-face Culling" dir="auto" class="heading" id="Back-face_Culling">Back-face Culling</h1><div class="heading-children"><div><p dir="auto">Cross Products detect if a set of points are backfacing or not <strong>if p0, p1 and p2 are in ccw order, then (p1-p0) cross (p2-p0) SHOULD be +ve.</strong><br>
<span alt="Pasted image 20240819015232.png" src="Pasted image 20240819015232.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819015232.png" src="lib/media/pasted-image-20240819015232.png"></span></p></div></div></div><div class="heading-wrapper"><h1 data-heading="Left/Right hand coordinate systems" dir="auto" class="heading" id="Left/Right_hand_coordinate_systems">Left/Right hand coordinate systems</h1><div class="heading-children"><div><p dir="auto">v1 cross v2 using right thumb rule. If match, is right hand. If not match, left hand.<br>
<span alt="Pasted image 20240819015340.png" src="Pasted image 20240819015340.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819015340.png" src="lib/media/pasted-image-20240819015340.png"></span></p></div></div></div><div class="heading-wrapper"><h1 data-heading="Interpolation" dir="auto" class="heading" id="Interpolation">Interpolation</h1><div class="heading-children"><div class="heading-wrapper"><h2 data-heading="Linear" dir="auto" class="heading" id="Linear"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Linear</h2><div class="heading-children"><div><p dir="auto">Simple shit.</p></div><div><pre><code>float Lerp (float start, float end, float t) {
  return (end - start) * t + start
}
</code><button class="copy-code-button">Copy</button></pre></div></div></div><div class="heading-wrapper"><h2 data-heading="Bilinear" dir="auto" class="heading" id="Bilinear"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Bilinear</h2><div class="heading-children"><div><p dir="auto">Bilinear Interpolation. Used when finding a middle pt between 4 2D points (in a parallelogram) using 2 ratios of the 2 edges.</p></div><div><pre><code>float BilinearInterp (Vec2 p0, Vec2 p1, Vec2 p2, Vec2 p3, float s, float t) {
  Vec2 p01 = Lerp(p0, p1, s);
  Vec2 p32 = Lerp(p3, p2, s);
  return Lerp(p01, p32, t);
}
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto"><span alt="Pasted image 20240819015600.png" src="Pasted image 20240819015600.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819015600.png" src="lib/media/pasted-image-20240819015600.png"></span></p></div></div></div><div class="heading-wrapper"><h2 data-heading="Barycentric" dir="auto" class="heading" id="Barycentric"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Barycentric</h2><div class="heading-children"><div><p dir="auto">Used to find a middle point of a triangle with 2 or 3 ratio values. If 2 of them are s and t, 3rd one will always be (1 - s - t). All weights need to add up to 1. So middle of triangle will have each weight be 0.33.</p></div><div class="heading-wrapper"><h3 data-heading="Point-Vector interpretation of Barycentric Coordinates" dir="auto" class="heading" id="Point-Vector_interpretation_of_Barycentric_Coordinates"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Point-Vector interpretation of Barycentric Coordinates</h3><div class="heading-children"><div><p dir="auto">TLDR: (1-t1-t2) is always paired with the original point (p0).<br>
t1 and t2 are paired with their "destinations" extending out from p0.<br>
<code>(1-t1-t2)p0 + t1p1 + t2p2 = a point inside triangle.</code></p></div><div><p dir="auto">Used when:<br>
GIVEN 3 PTS<br>
GIVEN 2/3 RATIOS<br>
NEED TO FIND POINT<br>
<span alt="Pasted image 20240819015705.png" src="Pasted image 20240819015705.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819015705.png" src="lib/media/pasted-image-20240819015705.png"></span></p></div></div></div><div class="heading-wrapper"><h3 data-heading="Area-Of-Triangle interpretation of Barycentric Combinations" dir="auto" class="heading" id="Area-Of-Triangle_interpretation_of_Barycentric_Combinations"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Area-Of-Triangle interpretation of Barycentric Combinations</h3><div class="heading-children"><div><p dir="auto">Uses the area of each triangle segment over the entire triangle area to get a ratio. This ratio is the weight for each point. Ratio will correspond the the barycentric coordinates of t0 t1 and t2.<br>
Kinda works on the principle that ratio of areas will all normalize to sum up to 1.</p></div><div><p dir="auto">Used when:<br>
GIVEN 3 PTS<br>
HAVE MID POINT<br>
NEED TO FIND RATIO</p></div><div><p dir="auto">TLDR: Ratio of A0 is paired with p0 (opp side), etcetc.<br>
The t0/t1/t2 that triangle segment ratios give will be paired to the OPPOSITE point.<br>
<span alt="Pasted image 20240819015824.png" src="Pasted image 20240819015824.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819015824.png" src="lib/media/pasted-image-20240819015824.png"></span><br>
Calculation:<br>
For 3D (and how 2D was derived too):<br>
<code>Area of triangle = 0.5 * base * height</code>.<br>
Let base be <code>p1-p0</code>. Height isn't aligned with axis, so use projection.<br>
Project either SLANTS of triangle onto normal of base.<br>
<code>Let normal of base be Nn normalized normal be n</code><br>
<code>2 possible normals, only take the normal in same dir as P2</code><br>
Normal of base, normalized: <code>N / ||N||</code><br>
Slant of triangle: <code>p2-p1</code><br>
Height = slant projected onto base normal. <code>height = (p2-p1).(N/||N||)</code><br>
Slap everything together. <code>Area of triangle = 0.5 * ||p1-p0|| * (p2-p1).(N / ||N||)</code><br>
Oh look u can cancel out <code>||p1-p0||</code> with <code>||N||</code>, because the normal of the base has the same magnitude.<br>
<code>Area of triangle = 0.5 * (p2-p1).Nc</code><br>
<code>2 * Area of triangle = (p2-p1).N</code> For optimization, since we'll divide both values with a 2x later anyway.<br>
Again, for optimization, pre-calculate value of 1/total area first then use that to multiply every loop.</p></div><div><p dir="auto">If you convert points into 2D, you will get the <strong>cross product formula for z component</strong>!<br>
How handy.</p></div><div><p dir="auto">For 2D: Use the Z value (magnitude) of the cross product of p1-p0 cross p2-p0 to get <strong>2*area of triangle</strong>. (u1v2 - u2v1)</p></div><div><p dir="auto">Then, 2*segment area / 2*total area = ratio. Also, ratio of last triangle segment will just be 1-t1-t2, no need to calculate the area.</p></div><div class="heading-wrapper"><h4 data-heading="Incremental Barycentric" dir="auto" class="heading" id="Incremental_Barycentric"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Incremental Barycentric</h4><div class="heading-children"><div><p dir="auto">Incremental barycentric equation: (1 - t1 - t2)p0 + t1p1 + t2p2 = new p<br>
Use triangle-area based eqn instead: (A0/A)p0 + (A1/A)p0 + (A2/A)p2 = new p </p></div><div><ol>
<li data-line="0" dir="auto">Calculate new p at desired starting x,y point (bottom left). </li>
<li data-line="1" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<ol start="2">
<li data-line="1" dir="auto">Calculate deltas. Delta in x dir is ???.</li>
</ol>
</li>
</ol></div></div></div></div></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="Vertex Pipeline" dir="auto" class="heading" id="Vertex_Pipeline">Vertex Pipeline</h1><div class="heading-children"><div><p dir="auto">The geometry/vertex pipeline is as follows:<br>
<code>Model &gt; World &gt; Camera &gt; Lighting (if any) &gt; Project (onto 2D cam Plane) &gt; Clip &gt; Persepctive division &gt; NDC &gt; Screen/Device Coords &gt; Framebuffer</code><br>
<img src="https://upload.wikimedia.org/wikipedia/commons/f/f8/Geometry_pipeline_en.svg" referrerpolicy="no-referrer"></p></div><div class="heading-wrapper"><h2 data-heading="Model" dir="auto" class="heading" id="Model"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Model</h2><div class="heading-children"><div><pre><code>The raw vertex points straight from a model file (.obj, .fbx etc).
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">These points work off 0,0,0 as the center of the model.</p></div></div></div><div class="heading-wrapper"><h2 data-heading="World" dir="auto" class="heading" id="World"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>World</h2><div class="heading-children"><div><p dir="auto">AKA the <strong>Model Transform</strong>. Model &gt; World. Exists for each unique object in the world.<br>
Applies the model's position, scale and rotation to "place" it into the world, with data from the Transform component.<br>
Concatenate the Scale, Rotation and Transform matrices together to get this matrix (in the order TRS).</p></div></div></div><div class="heading-wrapper"><h2 data-heading="View (Camera)" dir="auto" class="heading" id="View_(Camera)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>View (Camera)</h2><div class="heading-children"><div><p dir="auto">AKA the <strong>View Transform</strong>. World &gt; Camera. Exists for each unique camera.<br>
Brings the objects in the world to the camera's local coordinate system.</p></div><div><p dir="auto">We just want to rotate all objects in the world and shift them relative to where the camera is in world space, so that the camera is now at 0,0,0. Simple, just find the e1' e2' e3' vectors. No need to calculate rotation.</p></div><div><p dir="auto">Data required: Camera position, look direction, global up direction.</p></div><div><ol>
<li data-line="0" dir="auto">Determine if your camera should use a LEFT-HANDED or RIGHT-HANDED coordinate system.<br>
OpenGL and friends use a RIGHT-HANDED system, while DirectX uses LEFT-HANDED.<br>
Visualisation: <a rel="noopener" class="external-link" title="https://www.youtube.com/watch?v=TGbMzoJqV7c" href="https://www.youtube.com/watch?v=TGbMzoJqV7c" target="_blank">https://www.youtube.com/watch?v=TGbMzoJqV7c</a><br>
<span alt="Pasted image 20240819232059.png" src="Pasted image 20240819232059.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819232059.png" src="lib/media/pasted-image-20240819232059.png"></span><br>
The difference between a left/right hand system is if the positive Z-axis comes at your camera or goes away from the camera. The X and Y axis directions should remain the same for both systems.</li>
<li data-line="5" dir="auto">Figure out e3' first (Z/blue axis). For RIGHT-HANDED system, take camPos - targetPos (vector towards camera). For LEFT-HANDED system, the other way (vector away from camera). Normalize this vector, you got e3'.</li>
<li data-line="6" dir="auto">Next, figure out e1'. e2' (the camera y axis), e3' and global up and  all lie on the same plane. This means you can cross e3' and the global up to find e1' (X/red axis). Assuming global up is a unit vector, this cross product should result in a unit vector for e1', no normalization needed.
<blockquote dir="auto">
<p>Note: Be aware of the order of cross product! For LEFT-HANDED system, do e3' X globalUp. For RIGHT-HANDED system, do globalUP X e3'.</p>
</blockquote>
</li>
<li data-line="8" dir="auto">Lastly, you can find e2' by crossing e1' and e3' together. Again, be wary about the cross product order.
<blockquote dir="auto">
<p>For LEFT-HANDED system, do e1' X e3'. For RIGHT-HANDED system, do e3' X e1'.</p>
</blockquote>
</li>
</ol></div><div><p dir="auto">Finally, throw e1' e2' e3' into a matrix.</p></div><div><pre><code>| e1'.x e2'.x e3'.x camPos.x |
| e1'.y e2'.y e3'.y camPos.y |
| e1'.z e2'.z e3'.z camPos.z |
|  0     0     0       1     |
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">But hold on, this matrix is for LOCAL to GLOBAL. <strong>ALL default e1'e2'e3' matrices are LOCAL TO GLOBAL.</strong> So, need to inverse that matrix! Inverting 3x3 is a pain, so just memorize this formula:</p></div><div><pre><code>A = [ M   b  ]
    [ 0   1  ]
    
inv(A) = [ inv(M)   -inv(M) * b ]
         [   0            1     ]

| e1'.x  e1'.y  e1'.z  -e1'·camPos |
| e2'.x  e2'.y  e2'.z  -e2'·camPos |
| e3'.x  e3'.y  e3'.z  -e3'·camPos |
|   0      0      0         1      |

Note: last col is dot product, giving a scalar.
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto"><a rel="noopener" class="external-link" href="https://stackoverflow.com/questions/2624422/efficient-4x4-matrix-inverse-affine-transform" target="_blank">https://stackoverflow.com/questions/2624422/efficient-4x4-matrix-inverse-affine-transform</a><br>
Potential way to speed up Ax=b operations without finding A inverse: <a rel="noopener" class="external-link" href="https://www.johndcook.com/blog/2010/01/19/dont-invert-that-matrix/" target="_blank">https://www.johndcook.com/blog/2010/01/19/dont-invert-that-matrix/</a></p></div></div></div><div class="heading-wrapper"><h2 data-heading="Lighting" dir="auto" class="heading" id="Lighting"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Lighting</h2><div class="heading-children"><div><p dir="auto">From Wikipedia:</p></div><div><pre><code>Often a scene contains light sources placed at different positions to make the lighting of the objects appear more realistic. In this case, a gain factor for the texture is calculated for each vertex based on the light sources and the material properties associated with the corresponding triangle. In the later rasterization step, the vertex values of a triangle are interpolated over its surface. A general lighting (ambient light) is applied to all surfaces. It is the diffuse and thus direction-independent brightness of the scene. The sun is a directed light source, which can be assumed to be infinitely far away. The illumination effected by the sun on a surface is determined by forming the scalar product of the directional vector from the sun and the normal vector of the surface. If the value is negative, the surface is facing the sun. 
</code><button class="copy-code-button">Copy</button></pre></div></div></div><div class="heading-wrapper"><h2 data-heading="Projection" dir="auto" class="heading" id="Projection"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Projection</h2><div class="heading-children"><div><p dir="auto">2 Types of projection: Orthographic and Perspective.</p></div><div><p dir="auto">Orthographic Projection (aka Parallel projection): projection directions for all points are PARALLEL. Meaning the "clipping box" is a cuboid, not a trapezoid. </p></div><div><p dir="auto">Perspective projection: projection directions for all points are NOT PARALLEL. The "clipping box" trapezoid. All pixels from the start to end get scaled down accordingly to fit on the end plane. 'Gives the "fish eye" kind of view.</p></div><div class="heading-wrapper"><h3 data-heading="Orthographic Projection" dir="auto" class="heading" id="Orthographic_Projection"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Orthographic Projection</h3><div class="heading-children"><div><p dir="auto">Re-maps points in a volume in view space and plonks them into a 2x2x2 NDC space. Your cuboid volume in view space must be aligned to the axes, and can't be in an arbitrary position or shape.<br>
6 values to define the bounding volume in view space are specified to define this volume. (left, right, bottom, top, near, far)<br>
<span alt="Pasted image 20240825204651.png" src="Pasted image 20240825204651.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240825204651.png" src="lib/media/pasted-image-20240825204651.png"></span><br>
A few things need to happen:</p></div><div><ol>
<li data-line="0" dir="auto">Transform (move) the volume to be centered at origin</li>
<li data-line="1" dir="auto">Scale the points in the x, y, and z axes to fit into the 2x2x2 NDC space.</li>
</ol></div><div class="heading-wrapper"><h4 data-heading="Transform" dir="auto" class="heading" id="Transform"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Transform</h4><div class="heading-children"><div><p dir="auto">Find the center of your arbitrary volume using the 6 values, and then apply a transform. Simple.</p></div><div><pre><code>| 1 0 0 -Px |
| 0 1 0 -Py |
| 0 0 1 -Pz |
| 0 0 0  1  |
</code><button class="copy-code-button">Copy</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="Scale" dir="auto" class="heading" id="Scale"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Scale</h4><div class="heading-children"><div><p dir="auto">Find the size of your bounding volume, normalize the points into a 1x1x1 box, then x2 to the values to fit into a 2x2x2 volume.<br>
Working on a singular axis for visualization:</p></div><div><pre><code>Let point be x
Let box width be w

Map x from a w*h*d box into a 2*2*2 box:
x' = x / w * 2

Matrix to apply to point:
| 2/w  0   0  0 |   | x |
|  0  2/h  0  0 |   | y |
|  0   0  2/d 0 | * | z |
|  0   0   0  1 |   | 1 |
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">Of course, replace Px etc and w/h/d with the 6 corner values if needed.</p></div><div><p dir="auto">Concat the 2 matrices together, you get this:</p></div><div><pre><code>| 2/w  0   0  -Px |   | x |
|  0  2/h  0  -Py |   | y |
|  0   0  2/d -Pz | * | z |
|  0   0   0   1  |   | 1 |
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto"><span alt="Pasted image 20240826220306.png" src="Pasted image 20240826220306.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826220306.png" src="lib/media/pasted-image-20240826220306.png"></span><br>
One last caveat. OpenGL does its Z axis in the negative direction, so flip the Z value in the matrix to ensure your Z value in the NDC remains positive.</p></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="Simple Perspective Projection" dir="auto" class="heading" id="Simple_Perspective_Projection"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Simple Perspective Projection</h3><div class="heading-children"><div><p dir="auto"><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=U0_ONQQ5ZNM" rel="noopener" class="external-link" href="https://www.youtube.com/watch?v=U0_ONQQ5ZNM" target="_blank">Youtube Explanation</a><br>
Use the depth (Z) to calculate how much to map the X and Y values. Assume the Center of Projection is at origin.</p></div><div><p dir="auto">Define your projection plane (aka near plane) using a Z value, for example, -5. Denoted as Nz. Have a point, let its Z value be -6. Denoted as Pz.<br>
<span alt="Pasted image 20240826220851.png" src="Pasted image 20240826220851.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826220851.png" src="lib/media/pasted-image-20240826220851.png"></span><br>
To project the point P onto the projection plane, Pz' should be equal to Nz (-5). However, the X and Y values should be "interpolated". The value to interpolate by is the ratio of Nz to Pz.</p></div><div><p dir="auto">To find <code>Px'</code> and <code>Py'</code>, do:<br>
<code>Px' = Px / Pz * Nz</code></p></div><div><p dir="auto">Apply this formula to <code>Px, Py</code> and <code>Pz</code> to get <code>Px', Py'</code> and <code>Pz'</code>. </p></div><div><p dir="auto">Rewriting this to become easier to work with will give:<br>
<code>Px' = Px * Nz / Pz</code></p></div><div><p dir="auto"><code>Pz'</code> SHOULD end up equal to <code>Nz</code>.</p></div><div><blockquote dir="auto">
<p>Note: If the sign of both <code>Pz</code> and <code>Nz</code> values are different, it means the projection plane is on the wrong side, or your point is behind the camera. Either cull the point, or the point will be rendered upside down and the player can see behind the camera.</p>
</blockquote></div><div><p dir="auto">To express this in a matrix WITH perspective division, write it as such:</p></div><div><pre><code>| Px * Nz |   | Nz  0  0  0 |   | Px |
| Py * Nz |   |  0 Nz  0  0 |   | Py |
| Pz * Nz | = |  0  0 Nz  0 | * | Pz |
|   Pz    |   |  0  0  1  0 |   | 1  |
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">With the resultant matrix, divide the x y and z values with the w whenever convenient to get the final <code>Px' Py' Pz'</code> values.</p></div><div><p dir="auto">Again, note that both your <code>Pz</code> and <code>Nz</code> values are negative if the camera is pointing towards the -Z axis. Having the final divisor w be a negative will fix the x, y being negative and make z negative. Replacing the "1" with a "-1" in the matrix will do just that.</p></div><div><p dir="auto">From here, you can map the values to NDC by slapping it through a Screen Space to NDC matrix or something (now working in 2D space), or try to expand on this idea more by doing a full perspective projection.</p></div></div></div><div class="heading-wrapper"><h3 data-heading="Full Perspective Projection" dir="auto" class="heading" id="Full_Perspective_Projection"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Full Perspective Projection</h3><div class="heading-children"><div><p dir="auto">Now, we want to "preserve" the <code>Pz'</code> value after our projection.<br>
Reviewing what we have previously:</p></div><div><pre><code>| Nz  0  0  0 |   | Px |   | Px * Nz |   | Px * Nz / Pz |
|  0 Nz  0  0 |   | Py |   | Py * Nz |   | Px * Nz / Pz |
|  0  0 Nz  0 | * | Pz | = | Pz * Nz | = | Pz * Nz / Pz |
|  0  0  1  0 |   | 1  |   |   Pz    |
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">Focusing on the Z row: <code>Pz * Nz / Pz</code><br>
We can see that the z value of the evaluated point always resolves to Nz at the end. That's not good.</p></div><div><p dir="auto">Firstly, we can completely ignore the near plane value <code>Nz</code>. We purely want <code>Pz</code> at the end, and the near/far plane values don't matter (for now).<br>
So, we need this last bit to resolve to <code>Pz</code> if possible. This means that, for the previous step, instead of obtaining <code>Pz * Nz</code>, we should ideally obtain <code>Pz</code></p></div><div><p dir="auto">The only 2 values in the matrix we have to work with are the Nz value and the 0 to its right. Let's label them m1 and m2.</p></div><div><pre><code>| Nz  0  0  0  |   | Px |
|  0 Nz  0  0  |   | Py |
|  0  0 m1  m2 | * | Pz | = | Pz^2?? |
|  0  0  1  0  |   | 1  |
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">We can try to make an equation to obtain Pz^2 from this:<br>
<code>m1*Pz + m2 = Pz</code></p></div><div><p dir="auto">Unfortunately, there isn't a straightforward solution. There is no way to obtain <code>Pz</code>^2 for all values of <code>Pz</code>.<br>
This is now a quadratic equation, aka a curve.</p></div><div><p dir="auto">Now, solve for m1 and m2 simultaneously. This means we have to plug something into Pz. What values should we plug? Well, the near and far planes! (because what other values lol)<br>
For <code>Pz == n</code>, get eqn 1<br>
For <code>Pz == f</code>, get eqn 2<br>
Solve simultaneously to get:<br>
<code>m1 = f + n</code><br>
<code>m2 = -fn</code></p></div><div><p dir="auto">Plug this into the matrix:</p></div><div><pre><code>| Nz  0  0   0  |   | Px |
|  0 Nz  0   0  |   | Py |
|  0  0 f+n -fn | * | Pz | = | Pz^2... sometimes |
|  0  0  1   0  |   | 1  |
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">Caveats: This quadratic will NOT provide <code>Pz</code> all the time. However, it will still provide a value, <code>1/z</code>, that is still in order.<br>
Problems arise when n and f are too far apart, and the values obtained are too close together, thus resulting in z fighting.<br>
<img src="https://developer-blogs.nvidia.com/wp-content/uploads/2015/07/depth-perception-graph1-b.jpg" referrerpolicy="no-referrer"><br>
More on Z-fighting due to precision loss: <a rel="noopener" class="external-link" href="https://developer.nvidia.com/blog/visualizing-depth-precision/" target="_blank">https://developer.nvidia.com/blog/visualizing-depth-precision/</a><br>
One way to combat this issue, Reverse Z: <a rel="noopener" class="external-link" href="https://tomhultonharrop.com/mathematics/graphics/2023/08/06/reverse-z.html" target="_blank">https://tomhultonharrop.com/mathematics/graphics/2023/08/06/reverse-z.html</a></p></div><div><p dir="auto">Aite grape! Full perspective projection done, put it together with mapping into NDC and that's it.</p></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="Clipping: Liang-Barsky Algorithm" dir="auto" class="heading" id="Clipping:_Liang-Barsky_Algorithm"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Clipping: Liang-Barsky Algorithm</h2><div class="heading-children"><div><p dir="auto"><img src="https://upload.wikimedia.org/wikipedia/commons/0/01/Cube_clipping.svg" referrerpolicy="no-referrer"></p></div><div><p dir="auto"><span alt="Pasted image 20240826221425.png" src="Pasted image 20240826221425.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826221425.png" src="lib/media/pasted-image-20240826221425.png"></span><br>
<span alt="Pasted image 20240826221432.png" src="Pasted image 20240826221432.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826221432.png" src="lib/media/pasted-image-20240826221432.png"></span></p></div><div><p dir="auto">Uses the principle of P' = P + tV</p></div><div><p dir="auto">General Idea: Get the t value of line entry (tStart), and t value of line exit (tEnd).<br>
<span alt="Pasted image 20240826221522.png" src="Pasted image 20240826221522.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826221522.png" src="lib/media/pasted-image-20240826221522.png"></span><br>
Calculate the intersection of this line with every one of the 4 planes. You should get 4 t values: tLeft, tTop, tRight, tBottom. NOTE: we're calculating the t value, not the point itself.<br>
For tStart, you'll want to compare the t values that are in this manner: OUT to IN. (Not always tLeft and tBottom!)<br>
Vice versa for tEnd, you want to compare the t values that are IN to OUT.</p></div><div><p dir="auto">for tStart, you want the biggest t value (out of the 2, and t=0), tEnd the smallest t value(out of the 2 and t=1). That will be your intersection t values.</p></div><div><p dir="auto"><strong>Properties</strong></p></div><div><ul>
<li data-line="0" dir="auto">t value at 0 means the start point. t value at 1 means the end point. Usually we have 2 points, not a P+tV parametric equation.</li>
<li data-line="1" dir="auto">t values obtained can be out of the 0-1 range. any value out of this range is on this line but not within the line segment. That's why we cap values using 0 and 1 in our min/max functions.</li>
</ul></div><div><p dir="auto"><strong>Calculating t</strong><br>
Since plane is usually a normal, we do parametric and implicit line intersection.<br>
Follow the below formula.<br>
normal n is the first 2 values of ax+by+c=0, a and b.<br>
Point P is the starting point.<br>
Vector V is End point - Start point.</p></div><div><p dir="auto">Plug all values in and calculate t.<br>
<span alt="Pasted image 20240826221617.png" src="Pasted image 20240826221617.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826221617.png" src="lib/media/pasted-image-20240826221617.png"></span><br>
<span alt="Pasted image 20240826221624.png" src="Pasted image 20240826221624.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826221624.png" src="lib/media/pasted-image-20240826221624.png"></span></p></div><div><p dir="auto"><strong>Codifying</strong><br>
<span alt="Pasted image 20240826221720.png" src="Pasted image 20240826221720.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826221720.png" src="lib/media/pasted-image-20240826221720.png"></span><br>
Use a for loop to go thru all planes and calculate t.<br>
Each iteration, you have 2 points and a plane (with implicit equation ax+by+c=0).<br>
For each plane, check if your 2 points are going from OUT to IN of the plane, or the other way round.<br>
Normals are pointing OUT.<br>
U can use pre-computed values of the 2 points by subbing their x and y into ax+by+c. Result is distance from plane. -ve means IN, +ve means OUT.</p></div><div><p dir="auto">NOTE: At this point, check for horizontal/vertical edge cases. Horizontal lines can't intersect with the left and right planes, vice versa for horizontal lines.</p></div><div><p dir="auto">So if point 1 is +ve and point 2 is -ve, this t value should be considered for tStart.<br>
If point 1 is -ve and other one is +ve, this t value should be considered for tEnd.<br>
<span alt="Pasted image 20240826221740.png" src="Pasted image 20240826221740.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826221740.png" src="lib/media/pasted-image-20240826221740.png"></span><br>
Now u can have a method to distinguish t's that are for tStart and tEnd respectively.<br>
Compare each value with a saved tStart/tEnd value, and override each iteration if it is more/less. Refer to first pic above.</p></div><div><p dir="auto">FINALLY you have the proper tFirst and tLast values.</p></div><div><p dir="auto">If tFirst is after tLast, aka tFirst &gt; tLast, it means there is NO intersection</p></div><div class="heading-wrapper"><h3 data-heading="Frustum Checking" dir="auto" class="heading" id="Frustum_Checking"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Frustum Checking</h3><div class="heading-children"><div><p dir="auto"><strong>Using Clip-frame point itself to do inside-outside frustum check</strong></p></div><div><p dir="auto">Let's say you have a matrix to bring a value to clip frame. The matrix is encoded such that if the w value is used to do perspective division, the result will be in NDC.<br>
toClipFrame is a matrix designed to bring points to NDC via matrix multiplication AND persp division. But, we stop BEFORE persp division to do checking if point is in frustum or not.</p></div><div><p dir="auto">"Ok grape, I have a point in clip frame. what do?"<br>
If the camera is all aligned to the view origin and shit, GRAPE! Those 4 values x y z w are all you need to check if value is in or out of plane.</p></div><div><p dir="auto">Follow dis handy formula:<br>
Values below are calculated using ax+by+cz+d = 0 formula. Also means the result value is the distance of point to this plane.<br>
If value is +ve, point is out of plane, cos the normal is pointing OUTWARDS.</p></div><div><pre><code>Left:   -x - w
Right:   x - w
Bottom: -y - w
Top:     y - w
Near:   -z - w
Far:     z - w
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">For more info, cos this stupid matrix has NDC encoded in it, we can assume that each plane has nice values to use.</p></div><div><pre><code>Left:   [-1 0 0 -1]
Right:  [1 0 0 -1]
Bottom: [0 -1 0 -1]
Top:    [0 1 0 -1]
Near:   [0 0 -1 -1]
Far:    [0 0 1 -1]
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">These values supply the a,b,c,d values in the formula ax+by+cz+d = 0.<br>
So, subbing these values as a,b,c,d, and grabbing your existing point to sub in its x,y,z points (and also the w somehow), we can simplify each one into the table above.</p></div><div class="mod-footer"></div></div></div></div></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button is-collapsed" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#General"><div class="tree-item-contents heading-link" heading-name="General"><span class="tree-item-title">General</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Line_Rasterizaction"><div class="tree-item-contents heading-link" heading-name="Line Rasterizaction"><span class="tree-item-title">Line Rasterizaction</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Incremental_Line_Rasterization"><div class="tree-item-contents heading-link" heading-name="Incremental Line Rasterization"><span class="tree-item-title">Incremental Line Rasterization</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Triangle_Rasterization"><div class="tree-item-contents heading-link" heading-name="Triangle Rasterization"><span class="tree-item-title">Triangle Rasterization</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Edge_Walking"><div class="tree-item-contents heading-link" heading-name="Edge Walking"><span class="tree-item-title">Edge Walking</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Edge_Equation"><div class="tree-item-contents heading-link" heading-name="Edge Equation"><span class="tree-item-title">Edge Equation</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Texture_Mapping_Basics"><div class="tree-item-contents heading-link" heading-name="Texture Mapping Basics"><span class="tree-item-title">Texture Mapping Basics</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Texture_Space_VS_Texel_space"><div class="tree-item-contents heading-link" heading-name="Texture Space VS Texel space"><span class="tree-item-title">Texture Space VS Texel space</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Texture_Blending_(Decal)"><div class="tree-item-contents heading-link" heading-name="Texture Blending (Decal)"><span class="tree-item-title">Texture Blending (Decal)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Back-face_Culling"><div class="tree-item-contents heading-link" heading-name="Back-face Culling"><span class="tree-item-title">Back-face Culling</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Left/Right_hand_coordinate_systems"><div class="tree-item-contents heading-link" heading-name="Left/Right hand coordinate systems"><span class="tree-item-title">Left/Right hand coordinate systems</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Interpolation"><div class="tree-item-contents heading-link" heading-name="Interpolation"><span class="tree-item-title">Interpolation</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Linear"><div class="tree-item-contents heading-link" heading-name="Linear"><span class="tree-item-title">Linear</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Bilinear"><div class="tree-item-contents heading-link" heading-name="Bilinear"><span class="tree-item-title">Bilinear</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Barycentric"><div class="tree-item-contents heading-link" heading-name="Barycentric"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Barycentric</span></div></a><div class="tree-item-children nav-folder-children" style="display: none;"><div class="tree-item" data-depth="3"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Point-Vector_interpretation_of_Barycentric_Coordinates"><div class="tree-item-contents heading-link" heading-name="Point-Vector interpretation of Barycentric Coordinates"><span class="tree-item-title">Point-Vector interpretation of Barycentric Coordinates</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="3"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Area-Of-Triangle_interpretation_of_Barycentric_Combinations"><div class="tree-item-contents heading-link" heading-name="Area-Of-Triangle interpretation of Barycentric Combinations"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Area-Of-Triangle interpretation of Barycentric Combinations</span></div></a><div class="tree-item-children nav-folder-children" style="display: none;"><div class="tree-item" data-depth="4"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Incremental_Barycentric"><div class="tree-item-contents heading-link" heading-name="Incremental Barycentric"><span class="tree-item-title">Incremental Barycentric</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Vertex_Pipeline"><div class="tree-item-contents heading-link" heading-name="Vertex Pipeline"><span class="tree-item-title">Vertex Pipeline</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Model"><div class="tree-item-contents heading-link" heading-name="Model"><span class="tree-item-title">Model</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#World"><div class="tree-item-contents heading-link" heading-name="World"><span class="tree-item-title">World</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#View_(Camera)"><div class="tree-item-contents heading-link" heading-name="View (Camera)"><span class="tree-item-title">View (Camera)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Lighting"><div class="tree-item-contents heading-link" heading-name="Lighting"><span class="tree-item-title">Lighting</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Projection"><div class="tree-item-contents heading-link" heading-name="Projection"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Projection</span></div></a><div class="tree-item-children nav-folder-children" style="display: none;"><div class="tree-item mod-collapsible is-collapsed" data-depth="3"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Orthographic_Projection"><div class="tree-item-contents heading-link" heading-name="Orthographic Projection"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Orthographic Projection</span></div></a><div class="tree-item-children nav-folder-children" style="display: none;"><div class="tree-item" data-depth="4"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Transform"><div class="tree-item-contents heading-link" heading-name="Transform"><span class="tree-item-title">Transform</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Scale"><div class="tree-item-contents heading-link" heading-name="Scale"><span class="tree-item-title">Scale</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Simple_Perspective_Projection"><div class="tree-item-contents heading-link" heading-name="Simple Perspective Projection"><span class="tree-item-title">Simple Perspective Projection</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Full_Perspective_Projection"><div class="tree-item-contents heading-link" heading-name="Full Perspective Projection"><span class="tree-item-title">Full Perspective Projection</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Clipping:_Liang-Barsky_Algorithm"><div class="tree-item-contents heading-link" heading-name="Clipping: Liang-Barsky Algorithm"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Clipping: Liang-Barsky Algorithm</span></div></a><div class="tree-item-children nav-folder-children" style="display: none;"><div class="tree-item" data-depth="3"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Frustum_Checking"><div class="tree-item-contents heading-link" heading-name="Frustum Checking"><span class="tree-item-title">Frustum Checking</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>