<!DOCTYPE html> <html><head>
		<title>Rendering</title>
		<base href="../../../">
		<meta id="root-path" root-path="../../../">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<meta name="description" content="Documents - Rendering">
		<meta property="og:title" content="Rendering">
		<meta property="og:description" content="Documents - Rendering">
		<meta property="og:type" content="website">
		<meta property="og:url" content="https://azoor-desu.gitlab.io/azoor-desu/knowledgebase-&amp;-notes/programming/graphics/rendering.html">
		<meta property="og:image" content="https://azoor-desu.gitlab.io/azoor-desu/lib/media/pasted-image-20240819004713.png">
		<meta property="og:site_name" content="Documents">
		<meta name="author" content="Azoor"><script async="" id="webpage-script" src="lib/scripts/webpage.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><script async="" id="minisearch-script" src="https://cdn.jsdelivr.net/npm/minisearch@6.3.0/dist/umd/index.min.js" onload="this.onload=null;this.setAttribute(&quot;loaded&quot;, &quot;true&quot;)"></script><link rel="icon" href="lib/media/favicon.png"><style>body{--line-width:40em;--line-width-adaptive:40em;--file-line-width:40em;--sidebar-width:min(20em, 80vw);--collapse-arrow-size:11px;--tree-horizontal-spacing:0.6em;--tree-vertical-spacing:0.6em;--sidebar-margin:12px}.sidebar{height:100%;min-width:calc(var(--sidebar-width) + var(--divider-width-hover));max-width:calc(var(--sidebar-width) + var(--divider-width-hover));font-size:14px;z-index:10;position:relative;overflow:hidden;transition:min-width ease-in-out,max-width ease-in-out;transition-duration:.2s;contain:size}.sidebar-left{left:0}.sidebar-right{right:0}.sidebar.is-collapsed{min-width:0;max-width:0}body.floating-sidebars .sidebar{position:absolute}.sidebar-content{height:100%;min-width:calc(var(--sidebar-width) - var(--divider-width-hover));top:0;padding:var(--sidebar-margin);padding-top:4em;line-height:var(--line-height-tight);background-color:var(--background-secondary);transition:background-color,border-right,border-left,box-shadow;transition-duration:var(--color-fade-speed);transition-timing-function:ease-in-out;position:absolute;display:flex;flex-direction:column}.sidebar:not(.is-collapsed) .sidebar-content{min-width:calc(max(100%,var(--sidebar-width)) - 3px);max-width:calc(max(100%,var(--sidebar-width)) - 3px)}.sidebar-left .sidebar-content{left:0;border-top-right-radius:var(--radius-l);border-bottom-right-radius:var(--radius-l)}.sidebar-right .sidebar-content{right:0;border-top-left-radius:var(--radius-l);border-bottom-left-radius:var(--radius-l)}.sidebar:has(.sidebar-content:empty):has(.topbar-content:empty){display:none}.sidebar-topbar{height:2em;width:var(--sidebar-width);top:var(--sidebar-margin);padding-inline:var(--sidebar-margin);z-index:1;position:fixed;display:flex;align-items:center;transition:width ease-in-out;transition-duration:inherit}.sidebar.is-collapsed .sidebar-topbar{width:calc(2.3em + var(--sidebar-margin) * 2)}.sidebar .sidebar-topbar.is-collapsed{width:0}.sidebar-left .sidebar-topbar{left:0}.sidebar-right .sidebar-topbar{right:0}.topbar-content{overflow:hidden;overflow:clip;width:100%;height:100%;display:flex;align-items:center;transition:inherit}.sidebar.is-collapsed .topbar-content{width:0;transition:inherit}.clickable-icon.sidebar-collapse-icon{background-color:transparent;color:var(--icon-color-focused);padding:0!important;margin:0!important;height:100%!important;width:2.3em!important;margin-inline:0.14em!important;position:absolute}.sidebar-left .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);right:var(--sidebar-margin)}.sidebar-right .clickable-icon.sidebar-collapse-icon{transform:rotateY(180deg);left:var(--sidebar-margin)}.clickable-icon.sidebar-collapse-icon svg.svg-icon{width:100%;height:100%}.sidebar-section-header{margin:0 0 1em 0;text-transform:uppercase;letter-spacing:.06em;font-weight:600}body{transition:background-color var(--color-fade-speed) ease-in-out}.webpage-container{display:flex;flex-direction:row;height:100%;width:100%;align-items:stretch;justify-content:center}.document-container{opacity:1;flex-basis:100%;max-width:100%;width:100%;height:100%;display:flex;flex-direction:column;align-items:center;transition:opacity .2s ease-in-out;contain:inline-size}.hide{opacity:0;transition:opacity .2s ease-in-out}.document-container>.markdown-preview-view{margin:var(--sidebar-margin);margin-bottom:0;width:100%;width:-webkit-fill-available;width:-moz-available;width:fill-available;background-color:var(--background-primary);transition:background-color var(--color-fade-speed) ease-in-out;border-top-right-radius:var(--window-radius,var(--radius-m));border-top-left-radius:var(--window-radius,var(--radius-m));overflow-x:hidden!important;overflow-y:auto!important;display:flex!important;flex-direction:column!important;align-items:center!important;contain:inline-size}.document-container>.markdown-preview-view>.markdown-preview-sizer{padding-bottom:80vh!important;width:100%!important;max-width:var(--line-width)!important;flex-basis:var(--line-width)!important;transition:background-color var(--color-fade-speed) ease-in-out;contain:inline-size}.markdown-rendered img:not([width]),.view-content img:not([width]){max-width:100%;outline:0}.document-container>.view-content.embed{display:flex;padding:1em;height:100%;width:100%;align-items:center;justify-content:center}.document-container>.view-content.embed>*{max-width:100%;max-height:100%;object-fit:contain}:has(> :is(.math,table)){overflow-x:auto!important}.document-container>.view-content{overflow-x:auto;contain:content;padding:0;margin:0;height:100%}.scroll-highlight{position:absolute;width:100%;height:100%;pointer-events:none;z-index:1000;background-color:hsla(var(--color-accent-hsl),.25);opacity:0;padding:1em;inset:50%;translate:-50% -50%;border-radius:var(--radius-s)}</style><script defer="">async function loadIncludes(){if("file:"!=location.protocol){let e=document.querySelectorAll("include");for(let t=0;t<e.length;t++){let o=e[t],l=o.getAttribute("src");try{const e=await fetch(l);if(!e.ok){console.log("Could not include file: "+l),o?.remove();continue}let t=await e.text(),n=document.createRange().createContextualFragment(t),i=Array.from(n.children);for(let e of i)e.classList.add("hide"),e.style.transition="opacity 0.5s ease-in-out",setTimeout((()=>{e.classList.remove("hide")}),10);o.before(n),o.remove(),console.log("Included file: "+l)}catch(e){o?.remove(),console.log("Could not include file: "+l,e);continue}}}else{if(document.querySelectorAll("include").length>0){var e=document.createElement("div");e.id="error",e.textContent="Web server exports must be hosted on an http / web server to be viewed correctly.",e.style.position="fixed",e.style.top="50%",e.style.left="50%",e.style.transform="translate(-50%, -50%)",e.style.fontSize="1.5em",e.style.fontWeight="bold",e.style.textAlign="center",document.body.appendChild(e),document.querySelector(".document-container")?.classList.remove("hide")}}}document.addEventListener("DOMContentLoaded",(()=>{loadIncludes()}));let isFileProtocol="file:"==location.protocol;function waitLoadScripts(e,t){let o=e.map((e=>document.getElementById(e+"-script"))),l=0;!function e(){let n=o[l];l++,n&&"true"!=n.getAttribute("loaded")||l<o.length&&e(),l<o.length?n.addEventListener("load",e):t()}()}</script><link rel="stylesheet" href="lib/styles/obsidian.css"><link rel="preload" href="lib/styles/other-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/other-plugins.css"></noscript><link rel="stylesheet" href="lib/styles/theme.css"><link rel="preload" href="lib/styles/global-variable-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/global-variable-styles.css"></noscript><link rel="preload" href="lib/styles/supported-plugins.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/supported-plugins.css"></noscript><link rel="preload" href="lib/styles/main-styles.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="lib/styles/main-styles.css"></noscript></head><body class="publish css-settings-manager theme-dark show-inline-title show-ribbon outliner-plugin-dnd mk-readable-line mk-folder-lines mk-spaces-enabled mk-inline-context-enabled mk-flow-seamless"><script defer="">let theme=localStorage.getItem("theme")||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light");"dark"==theme?(document.body.classList.add("theme-dark"),document.body.classList.remove("theme-light")):(document.body.classList.add("theme-light"),document.body.classList.remove("theme-dark")),window.innerWidth<480?document.body.classList.add("is-phone"):window.innerWidth<768?document.body.classList.add("is-tablet"):window.innerWidth<1024?document.body.classList.add("is-small-screen"):document.body.classList.add("is-large-screen")</script><div class="webpage-container workspace"><div class="sidebar-left sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="search-input-container"><input enterkeyhint="search" type="search" spellcheck="false" placeholder="Search..."><div class="search-input-clear-button" aria-label="Clear search"></div></div><include src="lib/html/file-tree.html"></include></div><script defer="">let ls = document.querySelector(".sidebar-left"); ls.classList.add("is-collapsed"); if (window.innerWidth > 768) ls.classList.remove("is-collapsed"); ls.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-left-width"));</script></div><div class="document-container markdown-reading-view hide"><div class="markdown-preview-view markdown-rendered allow-fold-headings allow-fold-lists is-readable-line-width"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section"><h1 class="page-title heading inline-title" id="Rendering">Rendering</h1><div><pre><code># General
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">For GLSL/GLM, use <strong>COLUMN MAJOR</strong> format.</p></div><div><pre><code>0 3 6
1 4 7
2 5 8
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">Different of the usual ROW MAJOR format.</p></div><div><pre><code>0 1 2
3 4 5
6 7 8
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">Terms: <strong>Canonical</strong> means origin at bottom left</p></div><div><p dir="auto">3D Pipeline: <code>Model Coords &gt; World Coords &gt; View Coords(Cam local system) &gt; Lighting stuff &gt; Project onto Camera plane &gt; Clip Coords &gt; Persepctive division &gt; NDC *OPENGL TAKES OVER* &gt; Screen/Device Coords &gt; Framebuffer</code> </p></div><div><p dir="auto">2D Pipeline: <code>Model Coords &gt; World Coords &gt; View Coords(Cam local system) &gt; NDC *OPENGL TAKES OVER* &gt; Screen/Device Coords &gt; Framebuffer</code></p></div><div><p dir="auto">NDC: Origin at center, -1 to 1.<br>
Viewport: Origin Bottom Left, 2x2.</p></div><div><p dir="auto">Screen/Device Coords System:<br>
Origin TOP LEFT, size is dependent. If full device resolution, 1920x1080. If a window, then whatever the window size is e.g. 800x600. Windows OS has this layout.</p></div><div><blockquote dir="auto">
<p>OpenGL does conversion from NDC to Screen/Device Coords automagically.</p>
</blockquote></div><div class="heading-wrapper"><h1 data-heading="Line Rasterizaction" dir="auto" class="heading" id="Line_Rasterizaction">Line Rasterizaction</h1><div class="heading-children"><div><p dir="auto">Using y=mx+c, we can calculate which pixel is on the line as we iterate through each pixel on X axis. But we don't wanna run the m*x + c every iteration, more expensive. Instead, find the increment of y for every x (aka the m value) and use that to apply iteratively. </p></div><div><p dir="auto"><code>next x = last x + m</code>. </p></div><div><p dir="auto">Pros: Avoids a mult operation<br>
Cons: Will lose accuracy if done for long periods due to float inaccuracy. Does calculations in floats. Not the best.<br>
<span alt="Pasted image 20240819004713.png" src="Pasted image 20240819004713.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819004713.png" src="lib/media/pasted-image-20240819004713.png"></span></p></div><div><p dir="auto">If slope is &gt; 1, iterating across x will miss some pixels cos the behind pixel is being "covered". Instead, iterate via y instead, and use the slope of run/rise instead.<br>
<span alt="Pasted image 20240819004730.png" src="Pasted image 20240819004730.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819004730.png" src="lib/media/pasted-image-20240819004730.png"></span><br>
<span alt="Pasted image 20240819004735.png" src="Pasted image 20240819004735.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819004735.png" src="lib/media/pasted-image-20240819004735.png"></span><br>
Step 1: Iterate thru X values or Y values, depending on the slope and what startpoint/endpoint order is. Prepare a dy/dx or dx/dy value to increment to the not-iterating value. e.g. if iterating x, each x++ is +=dy/dx for y. </p></div><div><p dir="auto">Step 2: Let's say iterate Y value. Take the BOTTOM LEFT of each cell and see what X value it is. </p></div><div><p dir="auto">Step 3: Cell to be colored will be the Y value and X value! Visually, it's going to be the BOTTOM LEFT edges of the cell that is being "marked" by those 2 values. Step 4: iterate all the way, done. Make sure to leave the last cell unset if need line loops or sth.</p></div><div><p dir="auto"><span alt="Pasted image 20240819004819.png" src="Pasted image 20240819004819.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819004819.png" src="lib/media/pasted-image-20240819004819.png"></span></p></div><div><p dir="auto">Full Video Explanation:<br>
Bresenham's Algorithm<br>
<a rel="noopener" class="external-link" href="https://youtu.be/RGB-wlatStc?t=885" target="_blank">https://youtu.be/RGB-wlatStc?t=885</a></p></div><div><p dir="auto">Idea: For each X iteration, a Y value will be provided from the PREVIOUS iteration (unless it's the first iteration, Y value is alr given as the first point). That Y value will be either the same as the last Y value, or Y++. This algorithm figures out if the NEXT Y value should be ++ or not. </p></div><div><p dir="auto">To figure out if ++ or not, we use if( (d1-d2) &gt; 0). If this d1-d2 is -ve, use BOTTOM PIXEL. Else, TOP PIXEL.<br>
<span alt="Pasted image 20240819004904.png" src="Pasted image 20240819004904.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819004904.png" src="lib/media/pasted-image-20240819004904.png"></span><br>
d1 is calculated by the actual Y value of the line - current Y value d2 vice versa. </p></div><div><p dir="auto"><code>d1 - d2</code> is BOTTOM minus TOP. If value is +ve, bottom is fatter, hence line closer to TOP. Else closer to bottom. </p></div><div><p dir="auto">Take note if going the opposite way on the x or y axis will result in a different formula! </p></div><div><p dir="auto">But hol up, we still need to use m! That's a float and das not good.<br>
<span alt="Pasted image 20240819004933.png" src="Pasted image 20240819004933.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819004933.png" src="lib/media/pasted-image-20240819004933.png"></span><br>
we sub m = dy/dx and do algebra on it, then apply dx on both sides. now we got <code>dx(d1 - d2) = 2dy*xk - 2dx*yk + 2dy+2dx*c-dx</code><br>
This is a decision parameter, let's call it Pk. Prata calls it dk.<br>
<span alt="Pasted image 20240819004954.png" src="Pasted image 20240819004954.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819004954.png" src="lib/media/pasted-image-20240819004954.png"></span><br>
In formula <code>P(k) = 2dy*xk - 2dx*yk + 2dy+2dx*c-dx</code>, the last half <code>2dy+2dx*c-dx</code> got removed cos the next few steps are to find <code>P(k + 1) - P(k)</code>, and the constants would have cancelled each other out instantly.</p></div><div><p dir="auto"><code>P(k + 1) - P(k)</code> is useful for doing <em>incremental</em> calculations for the CPU for optimization. However, as a human, using P(k) is good enough.</p></div><div><p dir="auto">If P(k) is +ve, TOP pixel! Else, BOTTOM pixel! <strong>You probably cannot memorise this formula as it differs if you are doing in the negative direction.</strong></p></div><div><p dir="auto">However, when actually drawing lines, who the fuck cares, make your line start bottom left and go top right.</p></div><div><p dir="auto">Oh, and the c in the formula comes from y=mx+c.</p></div><div><p dir="auto">Do this:<br>
Using <code>y= mx + c</code>, sub in <code>dy/dx</code> and then rearrange to get <code>2dx*c = ???</code> At the end of the day you should get the equation for P(k) = xxx that just needs: the current (k) X and Y value, dy and dx.<br>
<span alt="Pasted image 20240819005048.png" src="Pasted image 20240819005048.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819005048.png" src="lib/media/pasted-image-20240819005048.png"></span><br>
and also one smol one for finding initial P<br>
<span alt="Pasted image 20240819005056.png" src="Pasted image 20240819005056.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819005056.png" src="lib/media/pasted-image-20240819005056.png"></span><br>
OK GRAPE TLDR FOR BRESENHAM:<br>
These formulas ONLY WORK for <strong>positive iterations</strong>. If you need to iterate backwards, well just don't lol. You can always choose to iterate forwards. Backwards will require a different formula that is really only useful for prata's exams.<br>
Check if each dy/dx value is +ve or -ve to determine the octant, and use that to decide each pixel should += 1 or -= 1 in X and Y directions.<br>
<strong>MODULUS THE dy AND dx VALUES FIRST BEFORE CONTINUING.</strong> This is making sure you're iterating forwards ON THE X AXIS, as the formula only works this way.</p></div><div><pre><code>Pinitial = 2dy - dx  // P1 to start out with
P+ve = 2dy - 2dx     // If current P value is +ve, add this value to get next P.
P-ve = 2dy           // If current P value is -ve, add this value to get next P.
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">If P is +ve this iteration, next step's y will += 1. If -ve, REMAIN AS SAME VALUE.</p></div><div><p dir="auto">OK grape, this is for slopes 0-1 for both +ve and -ve. How about 1-inf? Just flip the dys with the dxs in the formula, GRAPE. Also, be sure to iterate along the Y axis this time, not X.</p></div><div class="heading-wrapper"><h2 data-heading="Incremental Line Rasterization" dir="auto" class="heading" id="Incremental_Line_Rasterization"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Incremental Line Rasterization</h2><div class="heading-children"><div><p dir="auto">Incremental edge equation: ax+by+c = eval </p></div><div><ol>
<li data-line="0" dir="auto">Calculate eval at desired starting x,y point (bottom left). </li>
<li data-line="1" dir="auto">As you iterate over x++, the new (x+1, y) eval will be eval + a. Delta in x dir is a. 3</li>
<li data-line="2" dir="auto">As you move up to the next row using y++, take the eval value RIGHT BELOW the new point (not the one at the right side after u x++'d) and + b. so (x, y+1) will be eval + b. Delta in y dir is b.</li>
</ol></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="Triangle Rasterization" dir="auto" class="heading" id="Triangle_Rasterization">Triangle Rasterization</h1><div class="heading-children"><div><p dir="auto">When you want to "color" a grid of squares to best represent a triangle on the screen.</p></div><div class="heading-wrapper"><h2 data-heading="Edge Walking" dir="auto" class="heading" id="Edge_Walking"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Edge Walking</h2><div class="heading-children"><div><p dir="auto">An easy method, but inefficient.<br>
<strong>Edge Walking method:</strong> If triangle has no horizontal edge, use the MIDDLE vertex to draw a horizontal line to break a triangle into 2 pieces. Also, take note if this point is to the LEFT or RIGHT. For the 1/2 pieces of triangle, use the 2 corresponding line equations to compute the SPAN. For y = 5, what are the 2 x values for each line? Then iterate through these X values to calculate the fragment positions. </p></div><div><p dir="auto">PROS: Easy to use after implementation<br>
CONS: Too many edge cases. Complicated setup. Middle point to left or right? Do i need to cut the triangle? Cannot be parallelised. Serial computation.<br>
<span alt="Pasted image 20240819013535.png" src="Pasted image 20240819013535.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819013535.png" src="lib/media/pasted-image-20240819013535.png"></span></p></div></div></div><div class="heading-wrapper"><h2 data-heading="Edge Equation" dir="auto" class="heading" id="Edge_Equation"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Edge Equation</h2><div class="heading-children"><div><p dir="auto">A more sophisticated method: <strong>Edge Equation Method:</strong><br>
For each fragment, calculate if this current fragment is within the 3 lines. Each line will divide 2D plane into 2 regions, "inside" or "outside". If fragment is "inside" all 3 line equations, then it is inside the triangle.</p></div><div><p dir="auto">So it's just 3 dot product checks per fragment. Neat!<br>
<span alt="Pasted image 20240819013655.png" src="Pasted image 20240819013655.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819013655.png" src="lib/media/pasted-image-20240819013655.png"></span></p></div><div><p dir="auto">For standardization, use the LEFT normal. When dot product'ing a fragment (vector) to the normal, +ve means it's to the left of the line, which is "inside". This conforms with ccw winding of triangles, so DON'T use the right side normal. Given the vector, the left normal is: <code>[-v.y, v.x]</code>. Normalize as needed.<br>
<span alt="Pasted image 20240819013713.png" src="Pasted image 20240819013713.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819013713.png" src="lib/media/pasted-image-20240819013713.png"></span></p></div><div><p dir="auto">So now, the problem will be getting the line equation to do the computation of this inside-outside thing, from the 3 points of the triangle.</p></div><div><p dir="auto">For a given line, create an edge equation that returns a bool to see if fragment is inside or outside. Using point-normal formula explicit format: <code>L : ax + by + c == 0</code>, derived from <code>L: n . (x - p) == 0</code> Need to find <code>a</code>, <code>b</code> and <code>c</code>. <code>a</code> and <code>b</code> are the x and y values of the normal, <code>c</code> is just some fucked up value.<br>
<span alt="Pasted image 20240819014108.png" src="Pasted image 20240819014108.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819014108.png" src="lib/media/pasted-image-20240819014108.png"></span><br>
Hence the function should be: Take in point p and q, and variable point x. If (ax + by + c) &gt;= 0 then TRUE, else FALSE.</p></div><div><p dir="auto">Now here comes another issue: If the point/fragment/pixel lies directly on the the imaginary line, is it in or out? In other words, if (ax + by + c) == 0 then what do?</p></div><div><p dir="auto">Solution: Top left rule. If this line is a "top" line or "left" line of the triangle, then consider it inside. Else, out.</p></div><div><pre><code>Pre-computing Is Top or left edge boolean
if (a != 0) {
  if (a&gt;0) return true; // left edge
  else return false; // right edge
} 
else (a == 0){
  if (b&lt;0) return true; // top
  else return false; // not top
}
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto"><span alt="Pasted image 20240819014201.png" src="Pasted image 20240819014201.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819014201.png" src="lib/media/pasted-image-20240819014201.png"></span></p></div><div><p dir="auto">How to tell if a line/edge is a top/left/right?</p></div><div><p dir="auto">Identifying Top Edges and Left edges:<br>
Is Top when: If line is HORIZONTAL (X value of normal is == 0) and both y-values ABOVE the point/fragment/pixel.<br>
<span alt="Pasted image 20240819015000.png" src="Pasted image 20240819015000.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819015000.png" src="lib/media/pasted-image-20240819015000.png"></span><br>
Is Left when: X value of normal is &gt; 0. V is always pointing DOWNWARDS. Based on CCW winding, the next point that allows for CCW is always to the RIGHT.<br>
In <code>ax + by + c == 0</code>, <code>a == 0</code> and y values above last point is HORIZONTAL EDGE. <code>a &gt; 0</code> is LEFT EDGE<br>
<span alt="Pasted image 20240819015014.png" src="Pasted image 20240819015014.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819015014.png" src="lib/media/pasted-image-20240819015014.png"></span><br>
Note: If the top edge isn't perfectly HORIZONTAL, then it's either a left or right edge. There can also be 2 left edges. </p></div><div><p dir="auto">Also, when calculating if a PIXEL is in or out of the triangle, use its MID POINT. So the int coords of a fragment (x,y) will need to become (x + 0.5, y + 0.5) </p></div><div><p dir="auto">Calculate ax + by + c for every line. If value is +ve for all, fragment is INSIDE triangle.</p></div><div><p dir="auto">Therefore, TLDR:</p></div><div><pre><code>Pre-computing Is Top or left edge boolean for each edge:
if (a != 0) {
  if (a&gt;0) return true; // left edge
  else return false; // right edge
} 
else (a == 0){
  if (b&lt;0) return true; // top
  else return false; // not top
}
</code><button class="copy-code-button">Copy</button></pre></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="Texture Mapping Basics" dir="auto" class="heading" id="Texture_Mapping_Basics">Texture Mapping Basics</h1><div class="heading-children"><div class="heading-wrapper"><h2 data-heading="Texture Space VS Texel space" dir="auto" class="heading" id="Texture_Space_VS_Texel_space"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Texture Space VS Texel space</h2><div class="heading-children"><div><p dir="auto">TLDR: Texture space is NORMALIZED while Texel is in RAW PIXELS, INT ONLY. Note: Texel space can be used to represent a view port, OR the raw image itself (since the size of a raw image is pixels x pixels)<br>
<span alt="Pasted image 20240819005324.png" src="Pasted image 20240819005324.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819005324.png" src="lib/media/pasted-image-20240819005324.png"></span><br>
<span alt="Pasted image 20240819005329.png" src="Pasted image 20240819005329.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819005329.png" src="lib/media/pasted-image-20240819005329.png"></span><br>
With mapping, different methods of applying texture becomes available, such as:<br>
Tiling, stretching, mirroring etc.</p></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="Texture Blending (Decal)" dir="auto" class="heading" id="Texture_Blending_(Decal)">Texture Blending (Decal)</h1><div class="heading-children"><div><p dir="auto"><a rel="noopener" class="external-link" href="https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendFunc.xhtml" target="_blank">https://registry.khronos.org/OpenGL-Refpages/gl4/html/glBlendFunc.xhtml</a><br>
Consider an object with existing color. You apply a texture onto the object, and you want it to kind of "fade" in and out of the underlying texture, like a disappearing blood stain fading away.</p></div><div><p dir="auto">One method is to interpolate between these 2 textures using a singular value to determine if one texture or another is fully shown, or in-between.</p></div><div><p dir="auto">The formula is:<br>
<code>Final Color = InterpAmount * TexColor + (1 - InterpAmount) * ObjColor</code></p></div><div><p dir="auto">InterpAmount is the interpolation amount, and should be between 0 to 1.<br>
When value is 1, only TexColor is shown.<br>
When value is 0, only ObjColor is shown.<br>
Anything in between, there will be a color blend!</p></div></div></div><div class="heading-wrapper"><h1 data-heading="Back-face Culling" dir="auto" class="heading" id="Back-face_Culling">Back-face Culling</h1><div class="heading-children"><div><p dir="auto">Cross Products detect if a set of points are backfacing or not <strong>if p0, p1 and p2 are in ccw order, then (p1-p0) cross (p2-p0) SHOULD be +ve.</strong><br>
<span alt="Pasted image 20240819015232.png" src="Pasted image 20240819015232.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819015232.png" src="lib/media/pasted-image-20240819015232.png"></span></p></div></div></div><div class="heading-wrapper"><h1 data-heading="Left/Right hand coordinate systems" dir="auto" class="heading" id="Left/Right_hand_coordinate_systems">Left/Right hand coordinate systems</h1><div class="heading-children"><div><p dir="auto">v1 cross v2 using right thumb rule. If match, is right hand. If not match, left hand.<br>
<span alt="Pasted image 20240819015340.png" src="Pasted image 20240819015340.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819015340.png" src="lib/media/pasted-image-20240819015340.png"></span></p></div></div></div><div class="heading-wrapper"><h1 data-heading="Interpolation" dir="auto" class="heading" id="Interpolation">Interpolation</h1><div class="heading-children"><div class="heading-wrapper"><h2 data-heading="Linear" dir="auto" class="heading" id="Linear"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Linear</h2><div class="heading-children"><div><p dir="auto">Simple shit.</p></div><div><pre><code>float Lerp (float start, float end, float t) {
  return (end - start) * t + start
}
</code><button class="copy-code-button">Copy</button></pre></div></div></div><div class="heading-wrapper"><h2 data-heading="Bilinear" dir="auto" class="heading" id="Bilinear"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Bilinear</h2><div class="heading-children"><div><p dir="auto">Bilinear Interpolation. Used when finding a middle pt between 4 2D points (in a parallelogram) using 2 ratios of the 2 edges.</p></div><div><pre><code>float BilinearInterp (Vec2 p0, Vec2 p1, Vec2 p2, Vec2 p3, float s, float t) {
  Vec2 p01 = Lerp(p0, p1, s);
  Vec2 p32 = Lerp(p3, p2, s);
  return Lerp(p01, p32, t);
}
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto"><span alt="Pasted image 20240819015600.png" src="Pasted image 20240819015600.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819015600.png" src="lib/media/pasted-image-20240819015600.png"></span></p></div></div></div><div class="heading-wrapper"><h2 data-heading="Barycentric" dir="auto" class="heading" id="Barycentric"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Barycentric</h2><div class="heading-children"><div><p dir="auto">Used to find a middle point of a triangle with 2 or 3 ratio values. If 2 of them are s and t, 3rd one will always be (1 - s - t). All weights need to add up to 1. So middle of triangle will have each weight be 0.33.</p></div><div class="heading-wrapper"><h3 data-heading="Point-Vector interpretation of Barycentric Coordinates" dir="auto" class="heading" id="Point-Vector_interpretation_of_Barycentric_Coordinates"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Point-Vector interpretation of Barycentric Coordinates</h3><div class="heading-children"><div><p dir="auto">TLDR: (1-t1-t2) is always paired with the original point (p0).<br>
t1 and t2 are paired with their "destinations" extending out from p0.<br>
<code>(1-t1-t2)p0 + t1p1 + t2p2 = a point inside triangle.</code></p></div><div><p dir="auto">Used when:<br>
GIVEN 3 PTS<br>
GIVEN 2/3 RATIOS<br>
NEED TO FIND POINT<br>
<span alt="Pasted image 20240819015705.png" src="Pasted image 20240819015705.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819015705.png" src="lib/media/pasted-image-20240819015705.png"></span></p></div></div></div><div class="heading-wrapper"><h3 data-heading="Area-Of-Triangle interpretation of Barycentric Combinations" dir="auto" class="heading" id="Area-Of-Triangle_interpretation_of_Barycentric_Combinations"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Area-Of-Triangle interpretation of Barycentric Combinations</h3><div class="heading-children"><div><p dir="auto">Uses the area of each triangle segment over the entire triangle area to get a ratio. This ratio is the weight for each point. Ratio will correspond the the barycentric coordinates of t0 t1 and t2.<br>
Kinda works on the principle that ratio of areas will all normalize to sum up to 1.</p></div><div><p dir="auto">Used when:<br>
GIVEN 3 PTS<br>
HAVE MID POINT<br>
NEED TO FIND RATIO</p></div><div><p dir="auto">TLDR: Ratio of A0 is paired with p0 (opp side), etcetc.<br>
The t0/t1/t2 that triangle segment ratios give will be paired to the OPPOSITE point.<br>
<span alt="Pasted image 20240819015824.png" src="Pasted image 20240819015824.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819015824.png" src="lib/media/pasted-image-20240819015824.png"></span><br>
Calculation:<br>
For 3D (and how 2D was derived too):<br>
<code>Area of triangle = 0.5 * base * height</code>.<br>
Let base be <code>p1-p0</code>. Height isn't aligned with axis, so use projection.<br>
Project either SLANTS of triangle onto normal of base.<br>
<code>Let normal of base be Nn normalized normal be n</code><br>
<code>2 possible normals, only take the normal in same dir as P2</code><br>
Normal of base, normalized: <code>N / ||N||</code><br>
Slant of triangle: <code>p2-p1</code><br>
Height = slant projected onto base normal. <code>height = (p2-p1).(N/||N||)</code><br>
Slap everything together. <code>Area of triangle = 0.5 * ||p1-p0|| * (p2-p1).(N / ||N||)</code><br>
Oh look u can cancel out <code>||p1-p0||</code> with <code>||N||</code>, because the normal of the base has the same magnitude.<br>
<code>Area of triangle = 0.5 * (p2-p1).Nc</code><br>
<code>2 * Area of triangle = (p2-p1).N</code> For optimization, since we'll divide both values with a 2x later anyway.<br>
Again, for optimization, pre-calculate value of 1/total area first then use that to multiply every loop.</p></div><div><p dir="auto">If you convert points into 2D, you will get the <strong>cross product formula for z component</strong>!<br>
How handy.</p></div><div><p dir="auto">For 2D: Use the Z value (magnitude) of the cross product of p1-p0 cross p2-p0 to get <strong>2*area of triangle</strong>. (u1v2 - u2v1)</p></div><div><p dir="auto">Then, 2*segment area / 2*total area = ratio. Also, ratio of last triangle segment will just be 1-t1-t2, no need to calculate the area.</p></div><div class="heading-wrapper"><h4 data-heading="Incremental Barycentric" dir="auto" class="heading" id="Incremental_Barycentric"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Incremental Barycentric</h4><div class="heading-children"><div><p dir="auto">Incremental barycentric equation: (1 - t1 - t2)p0 + t1p1 + t2p2 = new p<br>
Use triangle-area based eqn instead: (A0/A)p0 + (A1/A)p0 + (A2/A)p2 = new p </p></div><div><ol>
<li data-line="0" dir="auto">Calculate new p at desired starting x,y point (bottom left). </li>
<li data-line="1" dir="auto"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>
<ol start="2">
<li data-line="1" dir="auto">Calculate deltas. Delta in x dir is ???.</li>
</ol>
</li>
</ol></div></div></div></div></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="Vertex Pipeline" dir="auto" class="heading" id="Vertex_Pipeline">Vertex Pipeline</h1><div class="heading-children"><div><p dir="auto">The geometry/vertex pipeline is as follows:<br>
<code>Model &gt; World &gt; Camera &gt; Lighting (if any) &gt; Project (onto 2D cam Plane) &gt; Clip &gt; Persepctive division &gt; NDC &gt; Screen/Device Coords &gt; Framebuffer</code><br>
<img src="https://upload.wikimedia.org/wikipedia/commons/f/f8/Geometry_pipeline_en.svg" referrerpolicy="no-referrer"></p></div><div class="heading-wrapper"><h2 data-heading="Model" dir="auto" class="heading" id="Model"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Model</h2><div class="heading-children"><div><pre><code>The raw vertex points straight from a model file (.obj, .fbx etc).
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">These points work off 0,0,0 as the center of the model.</p></div></div></div><div class="heading-wrapper"><h2 data-heading="World" dir="auto" class="heading" id="World"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>World</h2><div class="heading-children"><div><p dir="auto">AKA the <strong>Model Transform</strong>. Model &gt; World. Exists for each unique object in the world.<br>
Applies the model's position, scale and rotation to "place" it into the world, with data from the Transform component.<br>
Concatenate the Scale, Rotation and Transform matrices together to get this matrix (in the order TRS).</p></div></div></div><div class="heading-wrapper"><h2 data-heading="View (Camera)" dir="auto" class="heading" id="View_(Camera)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>View (Camera)</h2><div class="heading-children"><div><p dir="auto">AKA the <strong>View Transform</strong>. World &gt; Camera. Exists for each unique camera.<br>
Brings the objects in the world to the camera's local coordinate system.</p></div><div><p dir="auto">We just want to rotate all objects in the world and shift them relative to where the camera is in world space, so that the camera is now at 0,0,0. Simple, just find the e1' e2' e3' vectors. No need to calculate rotation.</p></div><div><p dir="auto">Data required: Camera position, look direction, global up direction.</p></div><div><ol>
<li data-line="0" dir="auto">Determine if your camera should use a LEFT-HANDED or RIGHT-HANDED coordinate system.<br>
OpenGL and friends use a RIGHT-HANDED system, while DirectX uses LEFT-HANDED.<br>
Visualisation: <a rel="noopener" class="external-link" title="https://www.youtube.com/watch?v=TGbMzoJqV7c" href="https://www.youtube.com/watch?v=TGbMzoJqV7c" target="_blank">https://www.youtube.com/watch?v=TGbMzoJqV7c</a><br>
<span alt="Pasted image 20240819232059.png" src="Pasted image 20240819232059.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240819232059.png" src="lib/media/pasted-image-20240819232059.png"></span><br>
The difference between a left/right hand system is if the positive Z-axis comes at your camera or goes away from the camera. The X and Y axis directions should remain the same for both systems.</li>
<li data-line="5" dir="auto">Figure out e3' first (Z/blue axis). For RIGHT-HANDED system, take camPos - targetPos (vector towards camera). For LEFT-HANDED system, the other way (vector away from camera). Normalize this vector, you got e3'.</li>
<li data-line="6" dir="auto">Next, figure out e1'. e2' (the camera y axis), e3' and global up and  all lie on the same plane. This means you can cross e3' and the global up to find e1' (X/red axis). Assuming global up is a unit vector, this cross product should result in a unit vector for e1', no normalization needed.
<blockquote dir="auto">
<p>Note: Be aware of the order of cross product! For LEFT-HANDED system, do e3' X globalUp. For RIGHT-HANDED system, do globalUP X e3'.</p>
</blockquote>
</li>
<li data-line="8" dir="auto">Lastly, you can find e2' by crossing e1' and e3' together. Again, be wary about the cross product order.
<blockquote dir="auto">
<p>For LEFT-HANDED system, do e1' X e3'. For RIGHT-HANDED system, do e3' X e1'.</p>
</blockquote>
</li>
</ol></div><div><p dir="auto">Finally, throw e1' e2' e3' into a matrix.</p></div><div><pre><code>| e1'.x e2'.x e3'.x camPos.x |
| e1'.y e2'.y e3'.y camPos.y |
| e1'.z e2'.z e3'.z camPos.z |
|  0     0     0       1     |
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">But hold on, this matrix is for LOCAL to GLOBAL. <strong>ALL default e1'e2'e3' matrices are LOCAL TO GLOBAL.</strong> So, we need to inverse that matrix! Inverting 3x3 is a pain... but thank goodness it's easy in this case. There's a special property of orthonormal 3x3 matrices (all 3 columns are orthogonal and normalized): the inverse of this matrix is the same as the transpose of this matrix! So we transpose the above matrix (the 3x3 portion) to get the below:</p></div><div><pre><code>| e1'.x  e1'.y  e1'.z  -e1'·camPos |
| e2'.x  e2'.y  e2'.z  -e2'·camPos |
| e3'.x  e3'.y  e3'.z  -e3'·camPos |
|   0      0      0         1      |

Note: 4th col is a dot product of 2 vectors, and not a regular period.
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto"><a rel="noopener" class="external-link" href="https://stackoverflow.com/questions/2624422/efficient-4x4-matrix-inverse-affine-transform" target="_blank">https://stackoverflow.com/questions/2624422/efficient-4x4-matrix-inverse-affine-transform</a><br>
Potential way to speed up Ax=b operations without finding A inverse: <a rel="noopener" class="external-link" href="https://www.johndcook.com/blog/2010/01/19/dont-invert-that-matrix/" target="_blank">https://www.johndcook.com/blog/2010/01/19/dont-invert-that-matrix/</a></p></div></div></div><div class="heading-wrapper"><h2 data-heading="Lighting" dir="auto" class="heading" id="Lighting"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Lighting</h2><div class="heading-children"><div><p dir="auto">From Wikipedia:</p></div><div><pre><code>Often a scene contains light sources placed at different positions to make the lighting of the objects appear more realistic. In this case, a gain factor for the texture is calculated for each vertex based on the light sources and the material properties associated with the corresponding triangle. In the later rasterization step, the vertex values of a triangle are interpolated over its surface. A general lighting (ambient light) is applied to all surfaces. It is the diffuse and thus direction-independent brightness of the scene. The sun is a directed light source, which can be assumed to be infinitely far away. The illumination effected by the sun on a surface is determined by forming the scalar product of the directional vector from the sun and the normal vector of the surface. If the value is negative, the surface is facing the sun. 
</code><button class="copy-code-button">Copy</button></pre></div></div></div><div class="heading-wrapper"><h2 data-heading="Projection" dir="auto" class="heading" id="Projection"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Projection</h2><div class="heading-children"><div><p dir="auto">2 Types of projection: Orthographic and Perspective.</p></div><div><p dir="auto">Orthographic Projection (aka Parallel projection): projection directions for all points are PARALLEL. Meaning the "clipping box" is a cuboid, not a trapezoid. </p></div><div><p dir="auto">Perspective projection: projection directions for all points are NOT PARALLEL. The "clipping box" trapezoid. All pixels from the start to end get scaled down accordingly to fit on the end plane. 'Gives the "fish eye" kind of view.</p></div><div class="heading-wrapper"><h3 data-heading="Orthographic Projection" dir="auto" class="heading" id="Orthographic_Projection"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Orthographic Projection</h3><div class="heading-children"><div><p dir="auto">Re-maps points in a volume in view space and plonks them into a 2x2x2 NDC space. Your cuboid volume in view space must be aligned to the axes, and can't be in an arbitrary position or shape.<br>
6 values to define the bounding volume in view space are specified to define this volume. (left, right, bottom, top, near, far)<br>
<span alt="Pasted image 20240825204651.png" src="Pasted image 20240825204651.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240825204651.png" src="lib/media/pasted-image-20240825204651.png"></span><br>
A few things need to happen:</p></div><div><ol>
<li data-line="0" dir="auto">Transform (move) the volume to be centered at origin</li>
<li data-line="1" dir="auto">Scale the points in the x, y, and z axes to fit into the 2x2x2 NDC space.</li>
</ol></div><div class="heading-wrapper"><h4 data-heading="Transform" dir="auto" class="heading" id="Transform"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Transform</h4><div class="heading-children"><div><p dir="auto">Find the center of your arbitrary volume using the 6 values, and then apply a transform. Simple.</p></div><div><pre><code>| 1 0 0 -Px |
| 0 1 0 -Py |
| 0 0 1 -Pz |
| 0 0 0  1  |
</code><button class="copy-code-button">Copy</button></pre></div></div></div><div class="heading-wrapper"><h4 data-heading="Scale" dir="auto" class="heading" id="Scale"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Scale</h4><div class="heading-children"><div><p dir="auto">Find the size of your bounding volume, normalize the points into a 1x1x1 box, then x2 to the values to fit into a 2x2x2 volume.<br>
Working on a singular axis for visualization:</p></div><div><pre><code>Let point be x
Let box width be w

Map x from a w*h*d box into a 2*2*2 box:
x' = x / w * 2

Matrix to apply to point:
| 2/w  0   0  0 |   | x |
|  0  2/h  0  0 |   | y |
|  0   0  2/d 0 | * | z |
|  0   0   0  1 |   | 1 |
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">Of course, replace Px etc and w/h/d with the 6 corner values if needed.</p></div><div><p dir="auto">Concat the 2 matrices together, you get this:</p></div><div><pre><code>| 2/w  0   0  -Px |   | x |
|  0  2/h  0  -Py |   | y |
|  0   0  2/d -Pz | * | z |
|  0   0   0   1  |   | 1 |
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto"><span alt="Pasted image 20240826220306.png" src="Pasted image 20240826220306.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826220306.png" src="lib/media/pasted-image-20240826220306.png"></span><br>
One last caveat. OpenGL does its Z axis in the negative direction, so flip the Z value in the matrix to ensure your Z value in the NDC remains positive.</p></div></div></div></div></div><div class="heading-wrapper"><h3 data-heading="Simple Perspective Projection" dir="auto" class="heading" id="Simple_Perspective_Projection"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Simple Perspective Projection</h3><div class="heading-children"><div><p dir="auto"><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=U0_ONQQ5ZNM" rel="noopener" class="external-link" href="https://www.youtube.com/watch?v=U0_ONQQ5ZNM" target="_blank">Youtube Explanation</a><br>
Use the depth (Z) to calculate how much to map the X and Y values. Assume the Center of Projection is at origin.</p></div><div><p dir="auto">Define your projection plane (aka near plane) using a Z value, for example, -5. Denoted as Nz. Have a point, let its Z value be -6. Denoted as Pz.<br>
<span alt="Pasted image 20240826220851.png" src="Pasted image 20240826220851.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826220851.png" src="lib/media/pasted-image-20240826220851.png"></span><br>
To project the point P onto the projection plane, Pz' should be equal to Nz (-5). However, the X and Y values should be "interpolated". The value to interpolate by is the ratio of Nz to Pz.</p></div><div><p dir="auto">To find <code>Px'</code> and <code>Py'</code>, do:<br>
<code>Px' = Px / Pz * Nz</code></p></div><div><p dir="auto">Apply this formula to <code>Px, Py</code> and <code>Pz</code> to get <code>Px', Py'</code> and <code>Pz'</code>. </p></div><div><p dir="auto">Rewriting this to become easier to work with will give:<br>
<code>Px' = Px * Nz / Pz</code></p></div><div><p dir="auto"><code>Pz'</code> SHOULD end up equal to <code>Nz</code>.</p></div><div><blockquote dir="auto">
<p>Note: If the sign of both <code>Pz</code> and <code>Nz</code> values are different, it means the projection plane is on the wrong side, or your point is behind the camera. Either cull the point, or the point will be rendered upside down and the player can see behind the camera.</p>
</blockquote></div><div><p dir="auto">To express this in a matrix WITH perspective division, write it as such:</p></div><div><pre><code>| Px * Nz |   | Nz  0  0  0 |   | Px |
| Py * Nz |   |  0 Nz  0  0 |   | Py |
| Pz * Nz | = |  0  0 Nz  0 | * | Pz |
|   Pz    |   |  0  0  1  0 |   | 1  |
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">With the resultant matrix, divide the x y and z values with the w whenever convenient to get the final <code>Px' Py' Pz'</code> values.</p></div><div><p dir="auto">Again, note that both your <code>Pz</code> and <code>Nz</code> values are negative if the camera is pointing towards the -Z axis. Having the final divisor w be a negative will fix the x, y being negative and make z negative. Replacing the "1" with a "-1" in the matrix will do just that.</p></div><div><p dir="auto">From here, you can map the values to NDC by slapping it through a Screen Space to NDC matrix or something (now working in 2D space), or try to expand on this idea more by doing a full perspective projection.</p></div></div></div><div class="heading-wrapper"><h3 data-heading="Full Perspective Projection" dir="auto" class="heading" id="Full_Perspective_Projection"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Full Perspective Projection</h3><div class="heading-children"><div><p dir="auto">Now, we want to "preserve" the <code>Pz'</code> value after our projection.<br>
Reviewing what we have previously:</p></div><div><pre><code>| Nz  0  0  0 |   | Px |   | Px * Nz |   | Px * Nz / Pz |
|  0 Nz  0  0 |   | Py |   | Py * Nz |   | Px * Nz / Pz |
|  0  0 Nz  0 | * | Pz | = | Pz * Nz | = | Pz * Nz / Pz |
|  0  0  1  0 |   | 1  |   |   Pz    |
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">Focusing on the final Z value: <code>Pz * Nz / Pz</code><br>
We can see that the z value of the evaluated point always resolves to Nz at the end. That's not good.</p></div><div><p dir="auto">We'd want our final Z value to match the original <code>Pz</code> value of the original point in the ideal scenario. This means that we can mostly ignore <code>Nz</code> for now and try to obtain <code>Pz</code> as our final Z value.<br>
This means that, for the previous step, instead of obtaining <code>Pz * Nz</code>, we should ideally obtain <code>Pz</code></p></div><div><pre><code>| Nz  0  0  0 |   | Px |   | Px * Nz |   | Px * Nz / Pz |
|  0 Nz  0  0 |   | Py |   | Py * Nz |   | Px * Nz / Pz |
|  ?  ?  ?  ? | * | Pz | = |   Pz^2  | = | Pz * Pz / Pz |
|  0  0  1  0 |   | 1  |   |   Pz    |
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">The only 2 values in the matrix we have to work with are the Nz value and the 0 to its right. Let's label them m1 and m2.</p></div><div><pre><code>| Nz  0  0  0  |   | Px |
|  0 Nz  0  0  |   | Py |
|  0  0 m1  m2 | * | Pz | = |   Pz^2  |
|  0  0  1  0  |   | 1  |
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">Focusing on the Z row, we can try to make an equation to obtain Pz^2 from this:<br>
<code>m1*Pz + m2 = Pz^2</code></p></div><div><p dir="auto">Unfortunately, there isn't a straightforward solution. There is no way to obtain <code>Pz</code>^2 for all values of <code>Pz</code>.<br>
This is now a quadratic equation, which results in a curve.</p></div><div><p dir="auto">Solve for m1 and m2 simultaneously. This means we have to plug something into Pz. What values should we plug? Well, the near and far planes! (because what other values asre there to use lol)<br>
When <code>Pz == n</code>, we get <code>m1*n + m2 = n^2</code><br>
When <code>Pz == f</code>, we get <code>m1*f + m2 = n^f</code><br>
Solve simultaneously to get:<br>
<code>m1 = f + n</code><br>
<code>m2 = -fn</code></p></div><div><p dir="auto">Plug this into the matrix:</p></div><div><pre><code>| Nz  0  0   0  |   | Px |
|  0 Nz  0   0  |   | Py |
|  0  0 f+n -fn | * | Pz | = | Pz^2... sometimes |
|  0  0  1   0  |   | 1  |
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">This solution is not the most ideal, but it's the closest we can get to the ideal value Pz.<br>
If we dig deeper, we can see that this final Z value has the property of <code>1/Pz</code>:</p></div><div><pre><code>Focusing on Z row: [...matrix...] = f+n-fn(1/Pz) = final Z value
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">Problems arise when n and f are too far apart, and the values obtained are too close together, thus resulting in z fighting.<br>
<img src="https://developer-blogs.nvidia.com/wp-content/uploads/2015/07/depth-perception-graph1-b.jpg" referrerpolicy="no-referrer"><br>
More on Z-fighting due to precision loss: <a rel="noopener" class="external-link" href="https://developer.nvidia.com/blog/visualizing-depth-precision/" target="_blank">https://developer.nvidia.com/blog/visualizing-depth-precision/</a><br>
To summarize:</p></div><div><ul>
<li data-line="0" dir="auto">The closer your z values are to 0, the more bunched up these ticks on the Z-axis will get.</li>
<li data-line="1" dir="auto">Moving objects a tiny bit in this z range will cause your d (depth) value to jump much more than if you moved the same tiny bit further out towards the far plane, causing higher chance of Z-fighting</li>
<li data-line="2" dir="auto">Floating-point precision inconsistencies with slightly different camera angles can be enough to cause the tiny value changes on the z-axis</li>
<li data-line="3" dir="auto">Moving your near plane closer to 0 will cause more intense Z-fighting as more values reside on the steeper portions of the graph. Moving the near plane further out will reduce Z-fighting.</li>
</ul></div><div><p dir="auto">One way to combat this issue, Reverse Z: <a rel="noopener" class="external-link" href="https://tomhultonharrop.com/mathematics/graphics/2023/08/06/reverse-z.html" target="_blank">https://tomhultonharrop.com/mathematics/graphics/2023/08/06/reverse-z.html</a><br>
<img src="https://developer-blogs.nvidia.com/wp-content/uploads/2021/05/depth-precision-graph5-625x324.jpg" referrerpolicy="no-referrer"><br>
We map the 0 and 1 the other way round instead, so that when Z-fighting happens, it happens further away from the camera. Now, moving your far plane further away will result in a higher chance of Z-fighting, leaving the closer objects less prone to Z-fighting.</p></div><div><p dir="auto">Aite great! Full perspective projection done, put it together with mapping into NDC and that's it.</p></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="Clipping: Liang-Barsky Algorithm" dir="auto" class="heading" id="Clipping:_Liang-Barsky_Algorithm"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Clipping: Liang-Barsky Algorithm</h2><div class="heading-children"><div><p dir="auto"><img src="https://upload.wikimedia.org/wikipedia/commons/0/01/Cube_clipping.svg" referrerpolicy="no-referrer"></p></div><div><p dir="auto"><span alt="Pasted image 20240826221425.png" src="Pasted image 20240826221425.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826221425.png" src="lib/media/pasted-image-20240826221425.png"></span><br>
<span alt="Pasted image 20240826221432.png" src="Pasted image 20240826221432.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826221432.png" src="lib/media/pasted-image-20240826221432.png"></span></p></div><div><p dir="auto">Uses the principle of P' = P + tV</p></div><div><p dir="auto">General Idea: Get the t value of line entry (tStart), and t value of line exit (tEnd).<br>
<span alt="Pasted image 20240826221522.png" src="Pasted image 20240826221522.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826221522.png" src="lib/media/pasted-image-20240826221522.png"></span><br>
Calculate the intersection of this line with every one of the 4 planes. You should get 4 t values: tLeft, tTop, tRight, tBottom. NOTE: we're calculating the t value, not the point itself.<br>
For tStart, you'll want to compare the t values that are in this manner: OUT to IN. (Not always tLeft and tBottom!)<br>
Vice versa for tEnd, you want to compare the t values that are IN to OUT.</p></div><div><p dir="auto">for tStart, you want the biggest t value (out of the 2, and t=0), tEnd the smallest t value(out of the 2 and t=1). That will be your intersection t values.</p></div><div><p dir="auto"><strong>Properties</strong></p></div><div><ul>
<li data-line="0" dir="auto">t value at 0 means the start point. t value at 1 means the end point. Usually we have 2 points, not a P+tV parametric equation.</li>
<li data-line="1" dir="auto">t values obtained can be out of the 0-1 range. any value out of this range is on this line but not within the line segment. That's why we cap values using 0 and 1 in our min/max functions.</li>
</ul></div><div><p dir="auto"><strong>Calculating t</strong><br>
Since plane is usually a normal, we do parametric and implicit line intersection.<br>
Follow the below formula.<br>
normal n is the first 2 values of ax+by+c=0, a and b.<br>
Point P is the starting point.<br>
Vector V is End point - Start point.</p></div><div><p dir="auto">Plug all values in and calculate t.<br>
<span alt="Pasted image 20240826221617.png" src="Pasted image 20240826221617.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826221617.png" src="lib/media/pasted-image-20240826221617.png"></span><br>
<span alt="Pasted image 20240826221624.png" src="Pasted image 20240826221624.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826221624.png" src="lib/media/pasted-image-20240826221624.png"></span></p></div><div><p dir="auto"><strong>Codifying</strong><br>
<span alt="Pasted image 20240826221720.png" src="Pasted image 20240826221720.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826221720.png" src="lib/media/pasted-image-20240826221720.png"></span><br>
Use a for loop to go thru all planes and calculate t.<br>
Each iteration, you have 2 points and a plane (with implicit equation ax+by+c=0).<br>
For each plane, check if your 2 points are going from OUT to IN of the plane, or the other way round.<br>
Normals are pointing OUT.<br>
U can use pre-computed values of the 2 points by subbing their x and y into ax+by+c. Result is distance from plane. -ve means IN, +ve means OUT.</p></div><div><p dir="auto">NOTE: At this point, check for horizontal/vertical edge cases. Horizontal lines can't intersect with the left and right planes, vice versa for horizontal lines.</p></div><div><p dir="auto">So if point 1 is +ve and point 2 is -ve, this t value should be considered for tStart.<br>
If point 1 is -ve and other one is +ve, this t value should be considered for tEnd.<br>
<span alt="Pasted image 20240826221740.png" src="Pasted image 20240826221740.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240826221740.png" src="lib/media/pasted-image-20240826221740.png"></span><br>
Now u can have a method to distinguish t's that are for tStart and tEnd respectively.<br>
Compare each value with a saved tStart/tEnd value, and override each iteration if it is more/less. Refer to first pic above.</p></div><div><p dir="auto">FINALLY you have the proper tFirst and tLast values.</p></div><div><p dir="auto">If tFirst is after tLast, aka tFirst &gt; tLast, it means there is NO intersection</p></div><div class="heading-wrapper"><h3 data-heading="Frustum Checking" dir="auto" class="heading" id="Frustum_Checking"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Frustum Checking</h3><div class="heading-children"><div><p dir="auto"><strong>Using Clip-frame point itself to do inside-outside frustum check</strong></p></div><div><p dir="auto">Let's say you have a matrix to bring a value to clip frame. The matrix is encoded such that if the w value is used to do perspective division, the result will be in NDC.<br>
toClipFrame is a matrix designed to bring points to NDC via matrix multiplication AND persp division. But, we stop BEFORE persp division to do checking if point is in frustum or not.</p></div><div><p dir="auto">"Ok grape, I have a point in clip frame. what do?"<br>
If the camera is all aligned to the view origin and shit, GRAPE! Those 4 values x y z w are all you need to check if value is in or out of plane.</p></div><div><p dir="auto">Follow dis handy formula:<br>
Values below are calculated using ax+by+cz+d = 0 formula. Also means the result value is the distance of point to this plane.<br>
If value is +ve, point is out of plane, cos the normal is pointing OUTWARDS.</p></div><div><pre><code>Left:   -x - w
Right:   x - w
Bottom: -y - w
Top:     y - w
Near:   -z - w
Far:     z - w
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">For more info, cos this stupid matrix has NDC encoded in it, we can assume that each plane has nice values to use.</p></div><div><pre><code>Left:   [-1 0 0 -1]
Right:  [1 0 0 -1]
Bottom: [0 -1 0 -1]
Top:    [0 1 0 -1]
Near:   [0 0 -1 -1]
Far:    [0 0 1 -1]
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">These values supply the a,b,c,d values in the formula ax+by+cz+d = 0.<br>
So, subbing these values as a,b,c,d, and grabbing your existing point to sub in its x,y,z points (and also the w somehow), we can simplify each one into the table above.</p></div></div></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="Lighting calulations" dir="auto" class="heading" id="Lighting_calulations">Lighting calulations</h1><div class="heading-children"><div class="heading-wrapper"><h2 data-heading="Shading" dir="auto" class="heading" id="Shading"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Shading</h2><div class="heading-children"><div><p dir="auto"><a rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Shading" target="_blank">https://en.wikipedia.org/wiki/Shading</a><br>
Shading is done by using a light source and a surface normal to determine the final color of what a pixel should be, based on the cosine of the angle of the normal and the light source.</p></div><div><p dir="auto">At 0 degrees (cos0 = 1), the light intensity should be 1.<br>
At 90 degrees (cos90 = 0), the light intensity should be 0.<br>
At &gt;90 degrees, clamp light intensity at 0 (because you can't have negative light).</p></div><div><p dir="auto">Dot product of 2 unit vectors conveniently gives us the cosine value, so we can use the dot product.<br>
<span alt="Pasted image 20240904221918.png" src="Pasted image 20240904221918.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240904221918.png" src="lib/media/pasted-image-20240904221918.png"></span></p></div><div class="heading-wrapper"><h3 data-heading="Faceted (Flat) Shading" dir="auto" class="heading" id="Faceted_(Flat)_Shading"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Faceted (Flat) Shading</h3><div class="heading-children"><div><p dir="auto">Super-fast shader.<br>
Basic idea is that all pixels on a triangle surface uses the same normal for lighting calculation. Since triangles have a flat surface, this means that all pixels in this triangle will have the same color value. The normal should be the triangle surface's normal.<br>
<span alt="Pasted image 20240904221948.png" src="Pasted image 20240904221948.png" class="internal-embed media-embed image-embed is-loaded"><img alt="Pasted image 20240904221948.png" src="lib/media/pasted-image-20240904221948.png"></span></p></div><div><p dir="auto">End result will look very... triangle-y. Each triangle face will be visibly shaded, but it's super fast.<br>
<img src="https://help.autodesk.com/cloudhelp/2023/ENU/MotionBuilder/images/GUID-A9B5C225-B9B6-4959-AB74-E5BF7739F0AA.png" referrerpolicy="no-referrer"></p></div></div></div><div class="heading-wrapper"><h3 data-heading="Gourad/Phong Shading" dir="auto" class="heading" id="Gourad/Phong_Shading"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Gourad/Phong Shading</h3><div class="heading-children"><div><p dir="auto">Gourad shading:<br>
The light intensity is calculated per vertex, and then this value is interpolated and passed to each fragment for color computation.</p></div><div><blockquote dir="auto">
<p>Majority of computation is offloaded to vertex shaders, making it fast, but lighting can look bad on low-poly models.</p>
</blockquote></div><div><p dir="auto">Phong shading:<br>
The normal is obtained per vertex, and this value is interpolated and passed to each fragment to calculate the light intensity per fragment, then applied to color computation.</p></div><div><blockquote dir="auto">
<p>Lighting is mostly performed on each fragment, lowering performance but improving the light quality</p>
</blockquote></div><div><p dir="auto"><img src="https://i.pcmag.com/imagery/encyclopedia-terms/gouraud-shading-_shading.fit_lim.size_1050x.gif" referrerpolicy="no-referrer"></p></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="Normal Mapping" dir="auto" class="heading" id="Normal_Mapping"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Normal Mapping</h2><div class="heading-children"><div><p dir="auto"><a rel="noopener" class="external-link" href="https://learnopengl.com/Advanced-Lighting/Normal-Mapping" target="_blank">https://learnopengl.com/Advanced-Lighting/Normal-Mapping</a><br>
Surface normals are used for lighting calculations.<br>
They are usually per-vertex or per-pixel. Per-pixel normal values can be stored in a "normal map"</p></div><div><p dir="auto">Normals help to calculate the angle of reflection of a texture surface. For a flat plane, the entire plane will have the same normal, thus it would make sense that it should look "smooth". For a bumpy wall, it would be expected that this wall would have some minor "bumps", and light bouncing off of this surface should not look flat. We can induce this effect using per-pixel normals that point in slightly different directions to make the surface not feel as "flat".<br>
<img src="https://learnopengl.com/img/advanced-lighting/normal_mapping_surfaces.png" referrerpolicy="no-referrer"><br>
When applied to an actual surface, it look like this:<br>
<img src="https://learnopengl.com/img/advanced-lighting/normal_mapping_compare.png" referrerpolicy="no-referrer"></p></div><div><p dir="auto">Ususally, raw model files (.fbx, .obj etc) should have per-vertex normals included. Per-vertex normals can be used to obtain per-fragment normals (blinn-phong), and then that would be used for lighting. However, custom bumpy surfaces like brick walls can't be interpolated from model per-vertex normals (how are you going to generate the normals along the seams and crevices?), so artists usually provide a normal map to get the accurate per-pixel lighting they want. These normal maps can be generated by their art/modelling software.<br>
<img src="https://artisticrender.com/wp-content/uploads/2022/05/ObjectNormalExample.jpg" referrerpolicy="no-referrer"></p></div><div class="heading-wrapper"><h3 data-heading="Types of Normal Maps" dir="auto" class="heading" id="Types_of_Normal_Maps"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Types of Normal Maps</h3><div class="heading-children"><div><p dir="auto">There are a few flavours when it comes to normal maps.<br>
You could have your normal maps in different systems: tangent space, object space and world space.<br>
The difference is the direction that these normals are pointing in, or how they are interpreted.<br>
<img src="https://lh5.googleusercontent.com/proxy/nvwe6QpZJ4YJLaW65I5llM1Tvk6DLz6pt2FBVqLtFD6DPYo8GUmCKSltBJ8eOrr2fe8vBplwRiW8sd2Tv_Gv86vzfAeOO31OdZKlvut2pcJ1XnoG9g" referrerpolicy="no-referrer"></p></div><div class="heading-wrapper"><h4 data-heading="Tangent Space" dir="auto" class="heading" id="Tangent_Space"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Tangent Space</h4><div class="heading-children"><div><p dir="auto"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/Image_Tangent-plane.svg/1920px-Image_Tangent-plane.svg.png" referrerpolicy="no-referrer"><br>
Tangent space maps always have the Z-axis pointing up away from the surface of the object (assuming a flat surface). Thus, the normal map will always have a blue-ish tint consistently across the whole map (because Z corresponds to B in a vector3).<br>
<img src="https://learnopengl.com/img/advanced-lighting/normal_mapping_normal_map.png" referrerpolicy="no-referrer"></p></div></div></div><div class="heading-wrapper"><h4 data-heading="Object Space" dir="auto" class="heading" id="Object_Space"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Object Space</h4><div class="heading-children"><div><p dir="auto">Each normal has their axes aligned to the axes of the object itself. This is different from tangent maps, where each normal's axes are aligned according to the surface of wherever each pixel rests on.</p></div></div></div><div class="heading-wrapper"><h4 data-heading="World Space" dir="auto" class="heading" id="World_Space"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>World Space</h4><div class="heading-children"><div><p dir="auto">Similar to object space, but instead of the axes aligning to the object, axes are aligned to the world.</p></div></div></div><div class="heading-wrapper"><h4 data-heading="What should you use" dir="auto" class="heading" id="What_should_you_use"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>What should you use</h4><div class="heading-children"><div><p dir="auto">From <a data-tooltip-position="top" aria-label="https://polycount.com/discussion/227725/difference-between-object-space-and-world-space-normals" rel="noopener" class="external-link" href="https://polycount.com/discussion/227725/difference-between-object-space-and-world-space-normals" target="_blank">this thread</a>:</p></div><div><blockquote dir="auto">
<p>Tangent space maps are more reusable (tiling textures for instance), and also work with skinned/deforming objects.<br>
They are also more prone to artefacts and the lighting calculation is slightly more complex (but negligible)<br>
For a non deforming asset with its own normal map, you could use object space.<br>
For completely static object with its own normal map, you could use world (but no one do this).<br>
Pretty much everybody use tangent.</p>
</blockquote></div></div></div><div class="heading-wrapper"><h4 data-heading="More reading" dir="auto" class="heading" id="More_reading"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>More reading</h4><div class="heading-children"><div><p dir="auto"><a rel="noopener" class="external-link" href="https://blenderartists.org/t/tangent-vs-object-space-vs-world-space/456423" target="_blank">https://blenderartists.org/t/tangent-vs-object-space-vs-world-space/456423</a></p></div></div></div></div></div></div></div><div class="heading-wrapper"><h2 data-heading="Lighting calculations with Tangent Space" dir="auto" class="heading" id="Lighting_calculations_with_Tangent_Space"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Lighting calculations with Tangent Space</h2><div class="heading-children"><div><p dir="auto">Normally, if we'd used world space or object space normals, computing the angle of reflection of a light ray is simple enough, as everything is in (almost) the same coordinate system.<br>
Let's assume we are going with tangent space normals instead.<br>
In order to use tangent normals for lighting, we'd need the light source and the normal to be in the same coordinate system. Right now, they are in different systems, world space and tangent space. Thus, we'd need to build a change-of-basis matrix to convert either the light or normal to the other space. For that, we'd need to obtain the 3 basis vectors to build the change-of-basis matrix, which are the Normal, Tangent and Bi-Tangent vectors. We'll need these vectors on a per-vertex basis.</p></div><div class="heading-wrapper"><h3 data-heading="Calculating Tangent and Bi-Tangent" dir="auto" class="heading" id="Calculating_Tangent_and_Bi-Tangent"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Calculating Tangent and Bi-Tangent</h3><div class="heading-children"><div><p dir="auto"><a rel="noopener" class="external-link" href="https://learnopengl.com/Advanced-Lighting/Normal-Mapping" target="_blank">https://learnopengl.com/Advanced-Lighting/Normal-Mapping</a><br>
Skippa skippa. Just note that this change of base matrix is called a TBN (Tangent, BI-tangent, Normal) matrix.<br>
TLDR: Calculate it manually when importing your assets, or use the importer tool (e.g. assimp) to generate tangent and bi-tangents.</p></div><div><blockquote dir="auto">
<p>If you're generating a custom mesh (e.g. generating terrain) you might have to do this calculation manually. This is usually implemented in tooling and not really for game runtime so that's a problem for next time.</p>
</blockquote></div><div><p dir="auto">After obtaining thsoe vectors, these per-vertex vectors should look something like that, witht the blue z axes pointing away from the surface instead of globally up:<br>
<img src="https://learnopengl.com/img/advanced-lighting/normal_mapping_tbn_shown.png" referrerpolicy="no-referrer"></p></div></div></div><div class="heading-wrapper"><h3 data-heading="Applying TBN in shaders" dir="auto" class="heading" id="Applying_TBN_in_shaders"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Applying TBN in shaders</h3><div class="heading-children"><div><p dir="auto">Our light and normals are still in different coordinate systems. But we now have a change-of-basis matrix!<br>
There are 2 ways to go about computing lighting:</p></div><div><ol>
<li data-line="0" dir="auto">Convert everything into world space and compute in world space</li>
<li data-line="1" dir="auto">Convert everything into tangent space and compute in tangent space</li>
</ol></div><div><p dir="auto">Hint: Computing in Tangent space is more efficient. Read more below.</p></div><div class="heading-wrapper"><h4 data-heading="1. Computing in World Space" dir="auto" class="heading" id="1._Computing_in_World_Space"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>1. Computing in World Space</h4><div class="heading-children"><div><p dir="auto">Need to convert the tangent space normal into world space normal. Light direction is already in world space.<br>
Compute the TBN matrix per-vertex, then pass the info to the fragment shader. It should look something like this in glsl vertex shader:</p></div><div><pre><code>// Inputs from host
layout (location = 0) in vec3 aPos;
layout (location = 1) in vec3 aNormal;
layout (location = 2) in vec2 aTexCoords;
layout (location = 3) in vec3 aTangent;
layout (location = 4) in vec3 aBitangent;  

// outputs for later shader stages (frag shader)
out VS_OUT {
    vec3 FragPos;
    vec2 TexCoords;
    mat3 TBN;
} vs_out;

void main()
{
   [...]
   vec3 T = normalize(vec3(model * vec4(aTangent,   0.0)));
   vec3 B = normalize(vec3(model * vec4(aBitangent, 0.0)));
   vec3 N = normalize(vec3(model * vec4(aNormal,    0.0)));
   vs_out.TBN = mat3(T, B, N); // compute TBN matrix and pass to frag shader
}
</code><button class="copy-code-button">Copy</button></pre></div><div><p dir="auto">In the fragment shader, you'd want to grab the normal from the texture map (still in tangent space), and then apply this TBN matrix to the tangent space normal. You'll get a world space normal. Now you can use this world space normal for lighting calculations!</p></div><div><pre><code>// Input from vert shader (WARNING: Values are interpolated)
in VS_OUT {
    vec3 FragPos;
    vec2 TexCoords;
    mat3 TBN;
} fs_in;  

normal = texture(normalMap, fs_in.TexCoords).rgb;   // extract normals from normal map. Normal is in Tangent Space.
normal = normal * 2.0 - 1.0;                        // Re-adjust normals extracted from map to turn it from range [0, 1] to [-1, 1]
normal = normalize(fs_in.TBN * normal);             // Apply TBN matrix to tangent space normal, get world space normal.
</code><button class="copy-code-button">Copy</button></pre></div><div><blockquote dir="auto">
<p>Note: When transferring data from vertex to fragment shader, values can't be passed 1 to 1. Instead, values passed from vertex shaders to fragment shaders are interpolated depending on their position in the triangle. This also means the values in your matrix are interpolated as well. This may cause the matrix to end up not being orthogonal when it reaches your fragment shader. You can try to re-orthogonalize the matrix by extracting 2 of the axes and then re-calculating the 3rd axis from cross-product-ing. Or you could use the matrix as-is but risk inaccurate normals.</p>
</blockquote></div></div></div><div class="heading-wrapper"><h4 data-heading="2. Computing in Tangent Space" dir="auto" class="heading" id="2._Computing_in_Tangent_Space"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>2. Computing in Tangent Space</h4><div class="heading-children"><div><p dir="auto">In the vertex shader, we compute the TBN matrix as usual. But this time, we need an inverse matrix of TBN, as we're converting things the other way round. Due to the matrix being orthogonal, transposing the matrix is the same as inverting the matrix.</p></div><div><p dir="auto">Now, instead of passing in the matrix to the fragment, we perform matrix multiplication in the vertex instead. What do we multiply? <em>Not</em> the normal, because that's in the fragment and not vertex. We instead pre-compute all the values we need for lighting calculations first before sending it over to the fragment shader.<br>
This means that you should pre-compute:</p></div><div><ul>
<li data-line="0" dir="auto">TangentLightPos</li>
<li data-line="1" dir="auto">TangentViewPos</li>
<li data-line="2" dir="auto">TangentFragPos</li>
</ul></div><div><p dir="auto">With these 3 values, and the tangent normal later, we can compute the lighting.</p></div><div><pre><code>// VERTEX SHADER
out VS_OUT {
    vec3 FragPos;
    vec2 TexCoords;
    vec3 TangentLightPos;
    vec3 TangentViewPos;
    vec3 TangentFragPos;
} vs_out;

uniform vec3 lightPos;
uniform vec3 viewPos;
 
[...]
  
void main()
{    
    [...]
    mat3 TBN = transpose(mat3(T, B, N));
    vs_out.TangentLightPos = TBN * lightPos;
    vs_out.TangentViewPos  = TBN * viewPos;
    vs_out.TangentFragPos  = TBN * vec3(model * vec4(aPos, 1.0));
}  

// FRAG SHADER
void main()
{           
    vec3 normal = texture(normalMap, fs_in.TexCoords).rgb;
    normal = normalize(normal * 2.0 - 1.0);   
   
   // normalize values because interpolated values from fs_in may not be normalized anymore
    vec3 lightDir = fs_in.TBN * normalize(lightPos - fs_in.FragPos); 
    vec3 viewDir  = fs_in.TBN * normalize(viewPos - fs_in.FragPos);    
    [...]
}  
</code><button class="copy-code-button">Copy</button></pre></div></div></div></div></div></div></div></div></div><div class="heading-wrapper"><h1 data-heading="Pipelines" dir="auto" class="heading" id="Pipelines">Pipelines</h1><div class="heading-children"><div class="heading-wrapper"><h2 data-heading="Vertex Shader Pipeline" dir="auto" class="heading" id="Vertex_Shader_Pipeline"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Vertex Shader Pipeline</h2><div class="heading-children"></div></div><div class="heading-wrapper"><h2 data-heading="Mesh Shader Pipeline" dir="auto" class="heading" id="Mesh_Shader_Pipeline"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Mesh Shader Pipeline</h2><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h1 data-heading="Shading" dir="auto" class="heading" id="Shading">Shading</h1><div class="heading-children"><div><p dir="auto"><a rel="noopener" class="external-link" href="https://www.aortiz.me/2018/12/21/CG.html" target="_blank">https://www.aortiz.me/2018/12/21/CG.html</a></p></div><div class="heading-wrapper"><h2 data-heading="Foward Render" dir="auto" class="heading" id="Foward_Render"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Foward Render</h2><div class="heading-children"></div></div><div class="heading-wrapper"><h2 data-heading="Foward+ Render" dir="auto" class="heading" id="Foward+_Render"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Foward+ Render</h2><div class="heading-children"><div><p dir="auto"><a rel="noopener" class="external-link" href="https://github.com/bcrusco/Forward-Plus-Renderer" target="_blank">https://github.com/bcrusco/Forward-Plus-Renderer</a></p></div></div></div><div class="heading-wrapper"><h2 data-heading="Deferred Render" dir="auto" class="heading" id="Deferred_Render"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Deferred Render</h2><div class="heading-children"></div></div><div class="heading-wrapper"><h2 data-heading="Tiled Shading" dir="auto" class="heading" id="Tiled_Shading"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Tiled Shading</h2><div class="heading-children"></div></div><div class="heading-wrapper"><h2 data-heading="Clustered Shading" dir="auto" class="heading" id="Clustered_Shading"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Clustered Shading</h2><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h1 data-heading="Culling" dir="auto" class="heading" id="Culling">Culling</h1><div class="heading-children"><div class="heading-wrapper"><h2 data-heading="Frustum Culling (CPU)" dir="auto" class="heading" id="Frustum_Culling_(CPU)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Frustum Culling (CPU)</h2><div class="heading-children"></div></div><div class="heading-wrapper"><h2 data-heading="Z Prepass" dir="auto" class="heading" id="Z_Prepass"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Z Prepass</h2><div class="heading-children"></div></div><div class="heading-wrapper"><h2 data-heading="HBZ" dir="auto" class="heading" id="HBZ"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>HBZ</h2><div class="heading-children"></div></div><div class="heading-wrapper"><h2 data-heading="Occlusion Culling (CPU)" dir="auto" class="heading" id="Occlusion_Culling_(CPU)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Occlusion Culling (CPU)</h2><div class="heading-children"></div></div><div class="heading-wrapper"><h2 data-heading="GPU Culling" dir="auto" class="heading" id="GPU_Culling"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>GPU Culling</h2><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h1 data-heading="Lighting" dir="auto" class="heading" id="Lighting">Lighting</h1><div class="heading-children"><div class="heading-wrapper"><h2 data-heading="PBR" dir="auto" class="heading" id="PBR"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>PBR</h2><div class="heading-children"></div></div><div class="heading-wrapper"><h2 data-heading="Raytracing" dir="auto" class="heading" id="Raytracing"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Raytracing</h2><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h1 data-heading="Shadows" dir="auto" class="heading" id="Shadows">Shadows</h1><div class="heading-children"><div class="heading-wrapper"><h2 data-heading="Shadow Map" dir="auto" class="heading" id="Shadow_Map"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Shadow Map</h2><div class="heading-children"><div><p dir="auto"><a rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Shadow_mapping" target="_blank">https://en.wikipedia.org/wiki/Shadow_mapping</a></p></div></div></div><div class="heading-wrapper"><h2 data-heading="Cascading Shadow Map" dir="auto" class="heading" id="Cascading_Shadow_Map"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Cascading Shadow Map</h2><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h1 data-heading="Instancing/Draw Calls" dir="auto" class="heading" id="Instancing/Draw_Calls">Instancing/Draw Calls</h1><div class="heading-children"><div class="heading-wrapper"><h2 data-heading="YOLO" dir="auto" class="heading" id="YOLO"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>YOLO</h2><div class="heading-children"><div><p dir="auto">Loop through each object and render each one with its own draw call.</p></div></div></div><div class="heading-wrapper"><h2 data-heading="Static Batching" dir="auto" class="heading" id="Static_Batching"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Static Batching</h2><div class="heading-children"></div></div><div class="heading-wrapper"><h2 data-heading="Dynamic Batching" dir="auto" class="heading" id="Dynamic_Batching"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Dynamic Batching</h2><div class="heading-children"></div></div><div class="heading-wrapper"><h2 data-heading="GPU Instance Renderer" dir="auto" class="heading" id="GPU_Instance_Renderer"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>GPU Instance Renderer</h2><div class="heading-children"><div><p dir="auto">Use single draw call to render multiple instances of a single object, but with different position, rotation scale etc.</p></div></div></div><div class="heading-wrapper"><h2 data-heading="Multi-Draw Indirect (GPU Rendering)" dir="auto" class="heading" id="Multi-Draw_Indirect_(GPU_Rendering)"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Multi-Draw Indirect (GPU Rendering)</h2><div class="heading-children"></div></div><div class="heading-wrapper"><h2 data-heading="Bindless" dir="auto" class="heading" id="Bindless"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Bindless</h2><div class="heading-children"></div></div></div></div><div class="heading-wrapper"><h1 data-heading="Power Efficient Rendering" dir="auto" class="heading" id="Power_Efficient_Rendering">Power Efficient Rendering</h1><div class="heading-children"><div><p dir="auto"><a rel="noopener" class="external-link" href="https://www.jonpeddie.com/news/trends-and-forecasts-in-computer-graphics-power-efficient-rendering/" target="_blank">https://www.jonpeddie.com/news/trends-and-forecasts-in-computer-graphics-power-efficient-rendering/</a><br>
Interesting things:</p></div><div><ul>
<li data-line="0" dir="auto">Immediate mode rendering may be more power efficient depending on the amount of updates. A dynamically switching render mode can be most power efficient.</li>
<li data-line="1" dir="auto">Regular rendering techniques also apply here.</li>
</ul></div><div class="mod-footer"></div></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-handle"></div><div class="sidebar-topbar"><div class="topbar-content"></div><div class="clickable-icon sidebar-collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round" class="svg-icon"><path d="M21 3H3C1.89543 3 1 3.89543 1 5V19C1 20.1046 1.89543 21 3 21H21C22.1046 21 23 20.1046 23 19V5C23 3.89543 22.1046 3 21 3Z"></path><path d="M10 4V20"></path><path d="M4 7H7"></path><path d="M4 10H7"></path><path d="M4 13H7"></path></svg></div></div><div class="sidebar-content"><div class="tree-container mod-root nav-folder tree-item outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button is-collapsed" aria-label="Collapse All"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg></button></div><div class="tree-scroll-area tree-item-children nav-folder-children"><div class="tree-item mod-tree-folder nav-folder mod-collapsible is-collapsed" style="display: none;"></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Rendering"><div class="tree-item-contents heading-link" heading-name="Rendering"><span class="tree-item-title">Rendering</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Line_Rasterizaction"><div class="tree-item-contents heading-link" heading-name="Line Rasterizaction"><span class="tree-item-title">Line Rasterizaction</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Incremental_Line_Rasterization"><div class="tree-item-contents heading-link" heading-name="Incremental Line Rasterization"><span class="tree-item-title">Incremental Line Rasterization</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Triangle_Rasterization"><div class="tree-item-contents heading-link" heading-name="Triangle Rasterization"><span class="tree-item-title">Triangle Rasterization</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Edge_Walking"><div class="tree-item-contents heading-link" heading-name="Edge Walking"><span class="tree-item-title">Edge Walking</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Edge_Equation"><div class="tree-item-contents heading-link" heading-name="Edge Equation"><span class="tree-item-title">Edge Equation</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Texture_Mapping_Basics"><div class="tree-item-contents heading-link" heading-name="Texture Mapping Basics"><span class="tree-item-title">Texture Mapping Basics</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Texture_Space_VS_Texel_space"><div class="tree-item-contents heading-link" heading-name="Texture Space VS Texel space"><span class="tree-item-title">Texture Space VS Texel space</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Texture_Blending_(Decal)"><div class="tree-item-contents heading-link" heading-name="Texture Blending (Decal)"><span class="tree-item-title">Texture Blending (Decal)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Back-face_Culling"><div class="tree-item-contents heading-link" heading-name="Back-face Culling"><span class="tree-item-title">Back-face Culling</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Left/Right_hand_coordinate_systems"><div class="tree-item-contents heading-link" heading-name="Left/Right hand coordinate systems"><span class="tree-item-title">Left/Right hand coordinate systems</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Interpolation"><div class="tree-item-contents heading-link" heading-name="Interpolation"><span class="tree-item-title">Interpolation</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Linear"><div class="tree-item-contents heading-link" heading-name="Linear"><span class="tree-item-title">Linear</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Bilinear"><div class="tree-item-contents heading-link" heading-name="Bilinear"><span class="tree-item-title">Bilinear</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Barycentric"><div class="tree-item-contents heading-link" heading-name="Barycentric"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Barycentric</span></div></a><div class="tree-item-children nav-folder-children" style="display: none;"><div class="tree-item" data-depth="3"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Point-Vector_interpretation_of_Barycentric_Coordinates"><div class="tree-item-contents heading-link" heading-name="Point-Vector interpretation of Barycentric Coordinates"><span class="tree-item-title">Point-Vector interpretation of Barycentric Coordinates</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="3"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Area-Of-Triangle_interpretation_of_Barycentric_Combinations"><div class="tree-item-contents heading-link" heading-name="Area-Of-Triangle interpretation of Barycentric Combinations"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Area-Of-Triangle interpretation of Barycentric Combinations</span></div></a><div class="tree-item-children nav-folder-children" style="display: none;"><div class="tree-item" data-depth="4"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Incremental_Barycentric"><div class="tree-item-contents heading-link" heading-name="Incremental Barycentric"><span class="tree-item-title">Incremental Barycentric</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Vertex_Pipeline"><div class="tree-item-contents heading-link" heading-name="Vertex Pipeline"><span class="tree-item-title">Vertex Pipeline</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Model"><div class="tree-item-contents heading-link" heading-name="Model"><span class="tree-item-title">Model</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#World"><div class="tree-item-contents heading-link" heading-name="World"><span class="tree-item-title">World</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#View_(Camera)"><div class="tree-item-contents heading-link" heading-name="View (Camera)"><span class="tree-item-title">View (Camera)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Lighting"><div class="tree-item-contents heading-link" heading-name="Lighting"><span class="tree-item-title">Lighting</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Projection"><div class="tree-item-contents heading-link" heading-name="Projection"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Projection</span></div></a><div class="tree-item-children nav-folder-children" style="display: none;"><div class="tree-item mod-collapsible is-collapsed" data-depth="3"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Orthographic_Projection"><div class="tree-item-contents heading-link" heading-name="Orthographic Projection"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Orthographic Projection</span></div></a><div class="tree-item-children nav-folder-children" style="display: none;"><div class="tree-item" data-depth="4"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Transform"><div class="tree-item-contents heading-link" heading-name="Transform"><span class="tree-item-title">Transform</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Scale"><div class="tree-item-contents heading-link" heading-name="Scale"><span class="tree-item-title">Scale</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Simple_Perspective_Projection"><div class="tree-item-contents heading-link" heading-name="Simple Perspective Projection"><span class="tree-item-title">Simple Perspective Projection</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Full_Perspective_Projection"><div class="tree-item-contents heading-link" heading-name="Full Perspective Projection"><span class="tree-item-title">Full Perspective Projection</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Clipping:_Liang-Barsky_Algorithm"><div class="tree-item-contents heading-link" heading-name="Clipping: Liang-Barsky Algorithm"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Clipping: Liang-Barsky Algorithm</span></div></a><div class="tree-item-children nav-folder-children" style="display: none;"><div class="tree-item" data-depth="3"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Frustum_Checking"><div class="tree-item-contents heading-link" heading-name="Frustum Checking"><span class="tree-item-title">Frustum Checking</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Lighting_calulations"><div class="tree-item-contents heading-link" heading-name="Lighting calulations"><span class="tree-item-title">Lighting calulations</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item mod-collapsible is-collapsed" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Shading"><div class="tree-item-contents heading-link" heading-name="Shading"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Shading</span></div></a><div class="tree-item-children nav-folder-children" style="display: none;"><div class="tree-item" data-depth="3"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Faceted_(Flat)_Shading"><div class="tree-item-contents heading-link" heading-name="Faceted (Flat) Shading"><span class="tree-item-title">Faceted (Flat) Shading</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="3"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Gourad/Phong_Shading"><div class="tree-item-contents heading-link" heading-name="Gourad/Phong Shading"><span class="tree-item-title">Gourad/Phong Shading</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Normal_Mapping"><div class="tree-item-contents heading-link" heading-name="Normal Mapping"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Normal Mapping</span></div></a><div class="tree-item-children nav-folder-children" style="display: none;"><div class="tree-item mod-collapsible is-collapsed" data-depth="3"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Types_of_Normal_Maps"><div class="tree-item-contents heading-link" heading-name="Types of Normal Maps"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Types of Normal Maps</span></div></a><div class="tree-item-children nav-folder-children" style="display: none;"><div class="tree-item" data-depth="4"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Tangent_Space"><div class="tree-item-contents heading-link" heading-name="Tangent Space"><span class="tree-item-title">Tangent Space</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Object_Space"><div class="tree-item-contents heading-link" heading-name="Object Space"><span class="tree-item-title">Object Space</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#World_Space"><div class="tree-item-contents heading-link" heading-name="World Space"><span class="tree-item-title">World Space</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#What_should_you_use"><div class="tree-item-contents heading-link" heading-name="What should you use"><span class="tree-item-title">What should you use</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#More_reading"><div class="tree-item-contents heading-link" heading-name="More reading"><span class="tree-item-title">More reading</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Lighting_calculations_with_Tangent_Space"><div class="tree-item-contents heading-link" heading-name="Lighting calculations with Tangent Space"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Lighting calculations with Tangent Space</span></div></a><div class="tree-item-children nav-folder-children" style="display: none;"><div class="tree-item" data-depth="3"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Calculating_Tangent_and_Bi-Tangent"><div class="tree-item-contents heading-link" heading-name="Calculating Tangent and Bi-Tangent"><span class="tree-item-title">Calculating Tangent and Bi-Tangent</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item mod-collapsible is-collapsed" data-depth="3"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Applying_TBN_in_shaders"><div class="tree-item-contents heading-link" heading-name="Applying TBN in shaders"><div class="collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><span class="tree-item-title">Applying TBN in shaders</span></div></a><div class="tree-item-children nav-folder-children" style="display: none;"><div class="tree-item" data-depth="4"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#1._Computing_in_World_Space"><div class="tree-item-contents heading-link" heading-name="1. Computing in World Space"><span class="tree-item-title">1. 
Computing in World Space
</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="4"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#2._Computing_in_Tangent_Space"><div class="tree-item-contents heading-link" heading-name="2. Computing in Tangent Space"><span class="tree-item-title">2. 
Computing in Tangent Space
</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Pipelines"><div class="tree-item-contents heading-link" heading-name="Pipelines"><span class="tree-item-title">Pipelines</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Vertex_Shader_Pipeline"><div class="tree-item-contents heading-link" heading-name="Vertex Shader Pipeline"><span class="tree-item-title">Vertex Shader Pipeline</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Mesh_Shader_Pipeline"><div class="tree-item-contents heading-link" heading-name="Mesh Shader Pipeline"><span class="tree-item-title">Mesh Shader Pipeline</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Shading"><div class="tree-item-contents heading-link" heading-name="Shading"><span class="tree-item-title">Shading</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Foward_Render"><div class="tree-item-contents heading-link" heading-name="Foward Render"><span class="tree-item-title">Foward Render</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Foward+_Render"><div class="tree-item-contents heading-link" heading-name="Foward+ Render"><span class="tree-item-title">Foward+ Render</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Deferred_Render"><div class="tree-item-contents heading-link" heading-name="Deferred Render"><span class="tree-item-title">Deferred Render</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Tiled_Shading"><div class="tree-item-contents heading-link" heading-name="Tiled Shading"><span class="tree-item-title">Tiled Shading</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Clustered_Shading"><div class="tree-item-contents heading-link" heading-name="Clustered Shading"><span class="tree-item-title">Clustered Shading</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Culling"><div class="tree-item-contents heading-link" heading-name="Culling"><span class="tree-item-title">Culling</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Frustum_Culling_(CPU)"><div class="tree-item-contents heading-link" heading-name="Frustum Culling (CPU)"><span class="tree-item-title">Frustum Culling (CPU)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Z_Prepass"><div class="tree-item-contents heading-link" heading-name="Z Prepass"><span class="tree-item-title">Z Prepass</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#HBZ"><div class="tree-item-contents heading-link" heading-name="HBZ"><span class="tree-item-title">HBZ</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Occlusion_Culling_(CPU)"><div class="tree-item-contents heading-link" heading-name="Occlusion Culling (CPU)"><span class="tree-item-title">Occlusion Culling (CPU)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#GPU_Culling"><div class="tree-item-contents heading-link" heading-name="GPU Culling"><span class="tree-item-title">GPU Culling</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Lighting"><div class="tree-item-contents heading-link" heading-name="Lighting"><span class="tree-item-title">Lighting</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#PBR"><div class="tree-item-contents heading-link" heading-name="PBR"><span class="tree-item-title">PBR</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Raytracing"><div class="tree-item-contents heading-link" heading-name="Raytracing"><span class="tree-item-title">Raytracing</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Shadows"><div class="tree-item-contents heading-link" heading-name="Shadows"><span class="tree-item-title">Shadows</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Shadow_Map"><div class="tree-item-contents heading-link" heading-name="Shadow Map"><span class="tree-item-title">Shadow Map</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Cascading_Shadow_Map"><div class="tree-item-contents heading-link" heading-name="Cascading Shadow Map"><span class="tree-item-title">Cascading Shadow Map</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Instancing/Draw_Calls"><div class="tree-item-contents heading-link" heading-name="Instancing/Draw Calls"><span class="tree-item-title">Instancing/Draw Calls</span></div></a><div class="tree-item-children nav-folder-children"><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#YOLO"><div class="tree-item-contents heading-link" heading-name="YOLO"><span class="tree-item-title">YOLO</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Static_Batching"><div class="tree-item-contents heading-link" heading-name="Static Batching"><span class="tree-item-title">Static Batching</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Dynamic_Batching"><div class="tree-item-contents heading-link" heading-name="Dynamic Batching"><span class="tree-item-title">Dynamic Batching</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#GPU_Instance_Renderer"><div class="tree-item-contents heading-link" heading-name="GPU Instance Renderer"><span class="tree-item-title">GPU Instance Renderer</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Multi-Draw_Indirect_(GPU_Rendering)"><div class="tree-item-contents heading-link" heading-name="Multi-Draw Indirect (GPU Rendering)"><span class="tree-item-title">Multi-Draw Indirect (GPU Rendering)</span></div></a><div class="tree-item-children nav-folder-children"></div></div><div class="tree-item" data-depth="2"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Bindless"><div class="tree-item-contents heading-link" heading-name="Bindless"><span class="tree-item-title">Bindless</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div><div class="tree-item" data-depth="1"><a class="tree-link" href="knowledgebase-&amp;-notes/programming/graphics/rendering.html#Power_Efficient_Rendering"><div class="tree-item-contents heading-link" heading-name="Power Efficient Rendering"><span class="tree-item-title">Power Efficient Rendering</span></div></a><div class="tree-item-children nav-folder-children"></div></div></div></div></div><script defer="">let rs = document.querySelector(".sidebar-right"); rs.classList.add("is-collapsed"); if (window.innerWidth > 768) rs.classList.remove("is-collapsed"); rs.style.setProperty("--sidebar-width", localStorage.getItem("sidebar-right-width"));</script></div></div></body></html>